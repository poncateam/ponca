
namespace Ponca
{
  /*!
    \page ponca_concepts %Ponca Concepts

    <center>[\ref user_manual_page "Go back to user manual"]</center>

    <hr>

    %Ponca is designed to be lightweight and easy to integrate in existing code bases.
    To achieve this goal:
     - %Ponca does not include datastructures to represent and store point cloud data, and let clients defining how to
       store and access data,
     - %Ponca cannot rely on C++ polymorphism to define its API: most computational objects used through the library
       involve very small computation. Combining these computation using polymorphism requires to use virtual functions,
       which introduce a very high overhead (considering the small computation of each class).
     - Instead, %Ponca is based on 'Concepts' that need to be followed to use/extend the library.

    Hence, we expect client code to define how point data can be accessed, by respecting the following interface:
    \snippet concepts.hpp PointConcept
    This represents the minimal API required to use %Ponca:
     - an integer `Dim` defining the number of dimensions of the ambient space (3 for 3d point clouds)
     - types `Scalar` and `VectorType` that will be used by the library to represent scalars and vectors
     - a default constructor
     - read and read/write access to an attribute describing the position of a point (`pos()`)

    Depending on the use cases, other types (e.g. `MatrixType`) or accessors (`normal()`) might be required.

    \see Example \ref example_cxx_binding_page, that demonstrate how to implement `PointConcept` in order to access
    point data in existing arrays without duplication.

    <hr>

    See concepts used in each modules:
     - \ref fitting_concepts


    <hr>
    <center>[\ref user_manual_page "Go back to user manual"]</center>


    \page fitting_concepts Fitting module: Concepts

    <center>[\ref fitting "Go back to Fitting user manual"]</center>
    <center>[\ref ponca_concepts "Go back to concept manual"]</center>
    <center>[\ref user_manual_page "Go back to user manual"]</center>

    <hr>

    %Ponca @ref fitting "Fitting Module" is structured around the following concepts:
    - `WeightKernelConcept`: defines how neighbor samples should be weighted
    - `ComputationalObjectConcept` and `ComputationalDerivativesConcept`: define API of the computational objects used
    in Basket and BasketDiff respectively.

    \section concepts_computeObject API of Computational Objects
    Computations will always follow the same pattern:
    \code
    // Definition
    typedef Basket<MyPointStructure,MyWeightingFunction,MyFittingProcedure...> Fit;

    // Initialization
    MyWeightingFunction w ( some_parameters );  //< Init weight function
    Fit fit;                                    //< Create a fit object
    fit.init(  );                               //< Initialize the internal state
    fit.setWeightFunc( {referencePosition, w} );  //< Set the weighting function (reference position and w can be shared accross multiple fits)

    // Computations
    foreach neighbors of referencePosition      //< Traverse neighborhood
      fit.addNeighbor(neighbor);                //< Intermediate computation for each neighbor
    fit.finalize();                             //< Final computations

    // Usage
    if(fit.isStable())
    {
        // use the fit ...
    }
    \endcode

    Note that in the above example, the type `Fit` can be either a Basket or a BasketDiff, without affecting the rest of
    the code.

    \subsection concepts_computeObjectBasket Objects used in Basket
    Objects used in Basket should respect the following API:
    \snippet concepts.hpp ComputationalObjectConcept

    \subsection concepts_computeObjectBasketDiff Objects used in BasketDiff
    Objects used in BasketDiff should respect the following API:
    \snippet concepts.hpp ComputationalDerivativesConcept

    \note PrimitiveDer defines the default entry point to most classes used in BasketDiff.

    \section concepts_provides Capabilities of the Fitting tools
    As described in \ref fitting_extensions_deps, The tool classes provides different kinds of compute capabilities.
    To describe what a class provides, we uses flags that allows us to check for compatibility at compile time.

    Here is an in depth description of all the labels of the Fitting tools :
    <table>
      <tr>
        <th>Label</th>
        <th>Provided by</th>
        <th>Required by</th>
        <th>Outputs</th>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_MEAN_POSITION</b><br>
            Mean of the input points vectors
        </td>
        <td>MeanPosition</td>
        <td>MeanPositionDer<br>MeanPlaneFitImpl<br>OrientedSphereFitImpl<br>CovarianceFitBase<br>UnorientedSphereFitImpl</td>
        <td>barycenter()<br>barycenterDistance()<br>barycenterLocal()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_MEAN_POSITION_DERIVATIVE</b><br>
            Provides derivative of the mean position
        </td>
        <td>MeanPositionDer</td>
        <td>CovarianceFitDer<br>OrientedSphereDerImpl<br>UnorientedSphereDerImpl</td>
        <td>barycenterDerivatives()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_MEAN_NORMAL</b><br>
            Mean of the normal vectors
        </td>
        <td>MeanNormal</td>
        <td>MeanPlaneFitImpl<br>OrientedSphereFitImpl</td>
        <td>meanNormalVector()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_MEAN_NORMAL_DERIVATIVE</b><br>
            Provides derivative of the mean normal
        </td>
        <td>MeanNormalDer</td>
        <td>-</td>
        <td>dMeanNormal()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_PRIMITIVE_BASE</b><br>
            Provides base API for primitives
        </td>
        <td>PrimitiveBase</td>
        <td>PrimitiveDer<br>AlgebraicSphere</td>
        <td>getWeightSum()<br>setNeighborFilter()<br>getNeighborFilter()<br>getCurrentState()<br>getNumNeighbors()<br>isReady()<br>isStable()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_PRIMITIVE_DERIVATIVE</b><br>
            Provides base API for primitive derivatives
        </td>
        <td>PrimitiveDer</td>
        <td>GLSDer<br>CovarianceFitDer<br>MeanPositionDer<br>MeanNormalDer<br>MlsSphereFitDer<br>OrientedSphereDerImpl<br>UnorientedSphereDerImpl</td>
        <td>isScaleDer()<br>isSpaceDer()<br>derDimension()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_GLS_PARAMETRIZATION</b><br>
            Growing Least Squares reparametrization of the OrientedSphereFit
        </td>
        <td>GLSParam</td>
        <td>GLSDer</td>
        <td>tau()<br>eta()<br>kappa()<br>tau_normalized()<br>eta_normalized()<br>kappa_normalized()<br>fitness()<br>compareTo()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_GLS_DERIVATIVE</b><br>
            Differentiation of GLSParam
        </td>
        <td>GLSDer</td>
        <td>-</td>
        <td>dtau()<br>deta()<br>dkappa()<br>dtau_normalized()<br>deta_normalized()<br>dkappa_normalized()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_GLS_GEOM_VAR</b><br>
            Provides Geometric Variation as a weighted sum of the GLS scale-invariant partial derivatives
        </td>
        <td>GLSDer</td>
        <td>-</td>
        <td>geomVar()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_ALGEBRAIC_SPHERE</b><br>

        </td>
        <td>AlgebraicSphere</td>
        <td>OrientedSphereFitImpl<br>OrientedSphereDerImpl<br>SphereFitImpl<br>UnorientedSphereFitImpl<br>UnorientedSphereDerImpl</td>
        <td>potential()<br>project()<br>primitiveGradient()<br>isPlane()<br>isValid()<br>isApprox()<br>changeBasis()<br>prattNorm()<br>prattNorm2()<br>applyPrattNorm()<br>radius()<br>center()<br>isNormalized()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_ALGEBRAIC_SPHERE_DERIVATIVE</b><br>
            Provides derivatives for algebraic sphere
        </td>
        <td>OrientedSphereDerImpl<br>UnorientedSphereDerImpl</td>
        <td>GLSDer<br>MlsSphereFitDer</td>
        <td>dPotential()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_COVARIANCE_PLANE_DERIVATIVE</b><br>
            Provides derivatives for hyper-planes
        </td>
        <td>CovariancePlaneDerImpl</td>
        <td>-</td>
        <td>dPotential()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_NORMAL_DERIVATIVE</b><br>
            Provides the derivatives of the primitive normal
        </td>
        <td>CovariancePlaneDerImpl<br>MlsSphereFitDer<br>OrientedSphereDerImpl<br>UnorientedSphereDerImpl</td>
        <td>NormalDerivativesCurvatureEstimator</td>
        <td>dNormal()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_POSITION_COVARIANCE</b><br>
            Provides the covariance matrix
        </td>
        <td>CovarianceFitBase</td>
        <td>CovarianceFitDer<br>CovarianceLineFitImpl<br>CovariancePlaneFitImpl</td>
        <td>solver()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_POSITION_COVARIANCE_DERIVATIVE</b><br>

        </td>
        <td>CovarianceFitDer</td>
        <td>CovariancePlaneDerImpl</td>
        <td>-</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_PLANE</b><br>

        </td>
        <td>Plane</td>
        <td style="word-break: break-word;">CovariancePlaneFitImpl<br>CovariancePlaneDerImpl<br>ProjectedNormalCovarianceCurvatureEstimator<br>MeanPlaneFitImpl<br>MongePatch</td>
        <td>setPlane()<br>potential()<br>project()<br>primitiveGradient()</td>
      </tr>

      <tr>
        <td>
            <b>PROVIDES_TANGENT_PLANE_BASIS</b><br>
            Turns a point in ambient 3D space to the tangent plane.
        </td>
        <td>CovariancePlaneFitImpl</td>
        <td>MongePatch</td>
        <td>worldToTangentPlane()<br>tangentPlaneToWorld()</td>
      </tr>
    </table>

    \section concepts_weighting Concepts related to weighting functions
    Weighting functions are critical components of the library.
    They are represented by DistWeightFunc, which is defined from the euclidean distance field centered at the
    evaluation position (see \ref DistWeightFunc::init()). Given a distance to this evaluation position, the weight
    is computed (see \ref DistWeightFunc::w()) by applying a 1d weighting function defined as follows:

   \snippet concepts.hpp WeightKernelConcept

   DistWeightFunc also provides computation of the first and second order derivatives of the weight, both in
   scale (\ref DistWeightFunc::scaledw(), \ref DistWeightFunc::scaled2w()) and space (\ref DistWeightFunc::spacedw(),
   \ref DistWeightFunc::spaced2w()), and their cross derivatives (\ref DistWeightFunc::scaleSpaced2w()).
   Theses methods check if the weight kernels provides the appropriate derivatives


    <hr>
    <center>[\ref fitting "Go back to Fitting user manual"]</center>
    <center>[\ref ponca_concepts "Go back to concept manual"]</center>
    <center>[\ref user_manual_page "Go back to user manual"]</center>
  */
} // End namespace Ponca
