namespace Ponca
{
/*!
  \page spatialpartitioning Spatial Partitioning: User Manual

  <center>[\ref user_manual_page "Go back to user manual"]</center>

  \tableofcontents

  \section spatialpartitioning_intro Introduction
  This module provides spatial datastructures to speed up spatial queries (e.g., neighbors search).

  \subsection spatialpartitioning_intro_structures Datastructures

   - Ponca::KdTree : a binary search tree (https://en.wikipedia.org/wiki/K-d_tree)
   - Ponca::KnnGraph : a nearest neighbor graph (https://en.wikipedia.org/wiki/Nearest_neighbor_graph). Constructed from
   a Ponca::KdTree.

   All datastructures are available in arbitrary dimensions.

  \subsection spatialpartitioning_intro_queries Queries
  Ponca queries are defined according to their input type (QueryInputIsIndex, or QueryInputIsPosition) and their
  output type (closest point with QueryOutputIsNearest, k-neighborhood with QueryOutputIsKNearest, and range
  neighborhood with QueryOutputIsRange):

  | QueryType  | Closest Point     | k-neighborhood     | Range neighborhood |
  |------------|-------------------|--------------------|--------------------|
  | Index      | NearestIndexQuery | KNearestIndexQuery | RangeIndexQuery    |
  | Coordinate | NearestPointQuery | KNearestPointQuery | RangePointQuery    |

  These classes provide a consistent API for all datastructures, where the results are exposed as `Range` and thus
  accessed through iterators, ie.:
  \code
#pragma omp parallel for
for (int i = 0; i < nbVert; ++i) // for all the vertices of the point cloud
  for (int neiId : myDataStructure.k_nearest_neighbors(i, k)) // collect k-nearest neighbors
  {
    // process neighbor at index neiId
  }
  \endcode

  \note As queries are objets that are independent from the datastructure, they can be created and used in parallel from
  multiple threads.
  The queries are always constructed by the datastructure.

  Thanks to the iterator formalism, queries can be seamlessly combined with Basket::computeWithIds:
  \code
Fit fit;
fit.setWeightFunc(MyWeightFunc(scale));
fit.init(fitInitPos);
fit.computeWithIds( myDataStructure.range_neighbors(fitInitPos, scale), vectorPoints );
  \endcode

  \warning Queries from an index (NearestIndexQuery, KNearestIndexQuery and RangeIndexQuery) do not iterate on the
  queried index.


  \section spatialpartitioning_kdtree KdTree
  \subsection spatialpartitioning_kdtree_usage Basic usage
  The class Ponca::KdTree provides methods to construct a tree and query points neighborhoods.

  \subsubsection spatialpartitioning_kdtree_usage_construction Construction
  As for the other modules, the point type is defined by a template parameter `DataPoint`.
  At construction time, the coordinates are copied in the tree from a container provided by the caller.
  For instance, to generate a tree from a random point cloud:
  \snippet tests/src/queries_knearest.cpp Kdtree construction

  For convenience, it is possible to convert the custom input points to `DataPoint` using a converter.

  Also, it is possible to provide a set of indices to sample a subset of the input point during the construction.
  Here, to randomly select half of the points:
  \snippet tests/src/queries_range.cpp Kdtree sampling construction


  \subsubsection spatialpartitioning_kdtree_usage_queries Queries
  As for other datastructures, queries are objects generated by Ponca::KdTree, and are designed as `Range`: accessing
  the neighbors requires to iterate over the query.
  Here an example from the test suite, where the indices returned from the queries are compared with an explicit search
  \snippet tests/src/queries_knearest.cpp Kdtree construction and query

  Several query types are provided (see KdTreeBase for related method list):
   - KdTreeKNearestQueryBase, specialized by KdTreeKNearestIndexQuery and KdTreeKNearestPointQuery
   - KdTreeNearestQueryBase, specialized by KdTreeNearestIndexQuery and KdTreeNearestPointQuery
   - KdTreeRangeQueryBase, specialized by KdTreeRangeIndexQuery and KdTreeRangePointQuery

  \subsection spatialpartitioning_kdtree_examples Examples

  Several KdTree queries are illustrated in the example \ref example_cxx_neighbor_search.
  KdTree usage is also demonstrated both in tests and examples:
   - `tests/src/basket.cpp`
   - `tests/src/queries_knearest.cpp`
   - `tests/src/queries_nearest.cpp`
   - `tests/src/queries_range.cpp`
   - `examples/cpp/nanoflann/ponca_nanoflann.cpp`

  \subsection spatialpartitioning_kdtree_extending Extending KdTree
  Ponca::KdTreeBase is a customizable version of Ponca::KdTree, which can be controlled using `Traits`.
  See KdTreeDefaultTraits for customization API.

  \subsection spatialpartitioning_kdtree_implementation Implementation details

  The kd-tree is a binary search tree that
  - is balanced (cuts at the median at each node)
  - cuts along the dimension that extends the most at each node
  - has a maximal depth (KdTreeDefaultTraits::MAX_DEPTH)
  - has a minimal number of points per leaf (KdTreeBase::m_min_cell_size)
  - only stores points in the leafs
  - uses depth-first search with a static stack for queries
  - keeps the initial order of points

  \section spatialpartitioning_knngraph KnnGraph
  \subsection spatialpartitioning_knngraph_usage Basic usage
  The class Ponca::KnnGraph provides methods to construct a neighbor graph and query points neighborhoods.

  \subsubsection spatialpartitioning_knngraph_usage_construction Construction
  The graph is constructed from an existing Ponca::KdTree, and the point collection is accessed through it (with no
  copy). Here an example from the test-suite where a graph is constructed, where only closest neighbors are connected:
  \snippet tests/src/queries_nearest.cpp KnnGraph construction

  \warning KnnGraph can only be constructed from KdTree without sub-sampling.

  \subsubsection spatialpartitioning_knngraph_usage_queries Queries
  As for other datastructures, queries are objects generated by Ponca::KdTree, and are designed as `Range`: accessing
  the neighbors requires to iterate over the query.
  \snippet tests/src/queries_knearest.cpp KnnGraph construction and query

  \note By construction, the KnnGraph can be queried only from an index.

  Two types of queries are provided (see KnnGraphBase for related method list):
   - KnnGraphRangeQuery
   - KnnGraphKNearestQuery: the number of neighbors is defined at construction-time: a k-neighbor graph gives access to
   k-neighborhoods only.
   \note The query KnnGraphNearestQuery does not need to exist explicitly as it boils down to KnnGraphKNearestQuery
   with `k=1`.





  <center>[\ref user_manual_page "Go back to user manual"]</center>
 */
}