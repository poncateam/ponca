namespace Ponca
{
/*!
  \page spatialpartitioning Spatial Partitioning: User Manual

  <center>[\ref user_manual_page "Go back to user manual"]</center>

  \tableofcontents

  \section spatialpartitioning_intro Introduction
  This module provides spatial datastructures to speed up spatial queries (e.g., neighbors search).

  \subsection spatialpartitioning_intro_structures Datastructures

   - Ponca::KdTreeDense and Ponca::KdTreeSparse: binary search trees (https://en.wikipedia.org/wiki/K-d_tree). Both
     classes inherit from Ponca::KdTree.
   - Ponca::KnnGraph : a nearest neighbor graph (https://en.wikipedia.org/wiki/nearestNeighbor_graph). Constructed from
   a Ponca::KdTree.

   All datastructures are available in arbitrary dimensions.

  \subsection spatialpartitioning_intro_queries Queries
  Ponca queries are defined according to their input type (QueryInputIsIndex, or QueryInputIsPosition) and their
  output type (closest point with QueryOutputIsNearest, k-neighborhood with QueryOutputIsKNearest, and range
  neighborhood with QueryOutputIsRange):

  | QueryType  | Closest Point     | k-neighborhood     | Range neighborhood |
  |------------|-------------------|--------------------|--------------------|
  | Index      | NearestIndexQuery | KNearestIndexQuery | RangeIndexQuery    |
  | Coordinate | NearestPointQuery | KNearestPointQuery | RangePointQuery    |

  These classes provide a consistent API for all datastructures, where the results are exposed as `Range` and thus
  accessed through iterators, ie.:
  \code
#pragma omp parallel for
for (int i = 0; i < nbVert; ++i) // for all the vertices of the point cloud
  for (int neiId : myDataStructure.kNearestNeighbors(i, k)) // collect k-nearest neighbors
  {
    // process neighbor at index neiId
  }
  \endcode

  \note As queries are objets that are independent from the datastructure, they can be created and used in parallel from
  multiple threads.
  The queries are always constructed by the datastructure.

  Thanks to the iterator formalism, queries can be seamlessly combined with Basket::computeWithIds:
  \code
Fit fit;
fit.setNeighborFilter({fitInitPos, scale});
fit.computeWithIds( myDataStructure.rangeNeighbors(fitInitPos, scale), vectorPoints );
  \endcode

  \warning Queries from an index (NearestIndexQuery, KNearestIndexQuery and RangeIndexQuery) do not iterate on the
  queried index.


  \section spatialpartitioning_kdtree KdTree

  \subsection spatialpartitioning_kdtree_implementation Specifications
  In Ponca, the kd-tree is a binary search tree that
  - is balanced (cuts at the median at each node),
  - cuts along the dimension that extends the most at each node,
  - has a maximal depth (KdTreeBase::MAX_DEPTH),
  - has a minimal number of points per leaf (KdTreeBase::m_min_cell_size),
  - only stores points in the leafs,
  - uses depth-first search with a static stack for queries,
  - keeps the initial order of points.

  \subsection spatialpartitioning_kdtree_usage Basic usage
  The class Ponca::KdTreeDense provides methods to construct a tree and query points neighborhoods. The class
  Ponca::KdTreeSparse provides the same functionalities as its dense counterpart, but allows construction from a subset
  of points. They both share the same API with their abstract base class KdTree.

  \subsubsection spatialpartitioning_kdtree_usage_construction Construction
  As for the other modules, the point type is defined by a template parameter `DataPoint`.
  At construction time, the coordinates are copied in the tree from a container provided by the caller.
  For instance, to generate a tree from a random point cloud:
  \snippet examples/cpp/ponca_neighbor_search.cpp Kdtree Dense construction

  For convenience, it is possible to convert the custom input points to `DataPoint` using a converter.

  When using a Ponca::KdTreeSparse, it is possible to provide a set of indices to sample a subset of the input point
  during the construction.
  Here, to randomly select half of the points:
  \snippet examples/cpp/ponca_neighbor_search.cpp Kdtree Sampling construction

  \subsubsection spatialpartitioning_kdtree_usage_queries Queries
  As for other datastructures, queries are objects generated by the KdTree, and are designed as `Range`: accessing
  the neighbors requires to iterate over the query.
  Here an example of the k nearest neighbors search of the point of index `query_idx` using the kd tree
  \snippet examples/cpp/ponca_neighbor_search.cpp Kdtree k-nearest neighbor index search

  Queries are mutable and can be reused. Here is an example of a query being reused with a different evaluation point index, `second_query_idx`.
  \snippet examples/cpp/ponca_neighbor_search.cpp Kdtree range neighbors index mutable search

  It is also possible to call for an empty query, and then perform the query call on it.
  \snippet examples/cpp/ponca_neighbor_search.cpp Kdtree range neighbors position mutable search
  The previous query is restricted to position based range query. To perform an index based research, a new query needs to be created.
  This is due to the fact that query returns object of it's own type, e.g., PointQuery or IndexQuery.

  Several query types are provided (see KdTreeBase for related method list):
   - KdTreeKNearestQueryBase, specialized by KdTreeKNearestIndexQuery and KdTreeKNearestPointQuery
   - KdTreeNearestQueryBase, specialized by KdTreeNearestIndexQuery and KdTreeNearestPointQuery
   - KdTreeRangeQueryBase, specialized by KdTreeRangeIndexQuery and KdTreeRangePointQuery

  Several KdTree queries are illustrated in the example \ref example_cxx_neighbor_search.
  KdTree usage is also demonstrated both in tests and examples:
   - `tests/src/basket.cpp`
   - `tests/src/queries_knearest.cpp`
   - `tests/src/queries_nearest.cpp`
   - `tests/src/queries_range.cpp`
   - `examples/cpp/nanoflann/ponca_nanoflann.cpp`
  
  \subsubsection spatialpartitioning_kdtree_usage_samples_and_indexing Samples and indexing
  There are two main ways of iterating over a KdTree: over points or over samples. Points are the underlying data
  storage, which the KdTree does not modify, while samples are a set of indices into the point storage that the KdTree
  reorders internally when it is constructed to keep track of spatial partitions.

  We call indices into the underlying point storage *point indices* and indices into the sample storage *sample
  indices*. Note that the sample storage stores point indices: sample number 0 may, for example, refer to point number 25.
  The point storage can be accessed with KdTreeBase::points, while the array of samples can be accessed with
  KdTreeBase::samples.

  While most of the KdTree API is built on using point indices, it can still be useful to iterate over samples instead
  (e.g. when using a Ponca::KdTreeSparse). If you ever need to convert sample indices to point indices, see
  KdTreeBase::pointFromSample (see also KdTreeBase::pointDataFromSample).


  \subsection spatialpartitioning_kdtree_extending Extending KdTree
  The trees can be customized using `Traits`, to change containers and nodes types. KdTreeDefaultTraits provides
  general-purpose `Traits` that fit most usages, and is directly used by Ponca::KdTree, Ponca::KdTreeDense and
  Ponca::KdTreeSparse:
  \snippet kdTree.h KdTree type definition
  \snippet kdTree.h KdTreeDense type definition
  \snippet kdTree.h KdTreeSparse type definition

  To use your own type of `Traits`, see KdTreeDefaultTraits and KdTreeCustomizableNode APIs. See also:
   - `examples/cpp/ponca_customize_kdtree.cpp`

  \subsection spatialpartitioning_kdtree_usage_which_class Usage of the convenience classes KdTree and KdTreeBase
  KdTree provides the common interface of KdTreeDense and KdTreeSparse. This class can be used to store
  or pass references/pointers that can be of either child type, see for instance:
  \snippet examples/cpp/ponca_neighbor_search.cpp KdTree pointer usage
  \snippet examples/cpp/ponca_neighbor_search.cpp KdTree assign sparse
  \snippet examples/cpp/ponca_neighbor_search.cpp KdTree assign dense

  KdTreeBase provides the same abstraction for arbitrary types of traits. When the type of `Traits` is not restricted,
  it is recommended to use KdTreeBase to declare functions parameters or variables. In this example:
  \snippet kdTreeQuery.h KdTreeQuery kdtree type
  the variable `m_kdtree` can be either dense or sparse, and have any type of `Traits`.

  \section spatialpartitioning_knngraph KnnGraph
  \subsection spatialpartitioning_knngraph_usage Basic usage
  The class Ponca::KnnGraph provides methods to construct a neighbor graph and query points neighborhoods.

  \subsubsection spatialpartitioning_knngraph_usage_construction Construction
  The graph is constructed from an existing KdTree, and the point collection is accessed through it (with no copy). Here
  an example from the test-suite where a graph is constructed, where only closest neighbors are connected:
  \snippet examples/cpp/ponca_neighbor_search.cpp KnnGraph construction

  \warning At the moment, a KnnGraph can only be constructed from a Ponca::KdTreeDense. This will change in a future
  release.

  \subsubsection spatialpartitioning_knngraph_usage_queries Queries
  As for other datastructures, queries are objects generated by KdTrees, and are designed as `Range`: accessing
  the neighbors requires to iterate over the query.
  \snippet examples/cpp/ponca_neighbor_search.cpp KnnGraph k-nearest neighbor index search

  \note By construction, the KnnGraph can be queried only from an index.

  Queries from KnnGraph are also mutable, and can be reused. Here is an example that creates an empty query, and then iterates over the rangeNeighbors index search.
  \snippet examples/cpp/ponca_neighbor_search.cpp KnnGraph range neighbors index mutable search

  Two types of queries are provided (see KnnGraphBase for related method list):
   - KnnGraphRangeQuery
   - KnnGraphKNearestQuery: the number of neighbors is defined at construction-time: a k-neighbor graph gives access to
   k-neighborhoods only.
   \note The query KnnGraphNearestQuery does not need to exist explicitly as it boils down to KnnGraphKNearestQuery
   with `k=1`.





  <center>[\ref user_manual_page "Go back to user manual"]</center>
 */
}
