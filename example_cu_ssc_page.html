<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ponca: Screen Space Curvature using Cuda/C++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ponca.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ponca
   &#160;<span id="projectnumber">49f0ce03c594b249853f9b1fb2884cfa47a41381</span>
   </div>
   <div id="projectbrief">Point Cloud Analysis library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="example_page.html">Examples</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Screen Space Curvature using Cuda/C++ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="cu_ssgl_intro_sec"></a>
Introduction</h1>
<p>This is an example that use <a class="el" href="namespace_ponca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a> to compute Screen Space Curvature in C++ using Cuda.</p>
<h2><a class="anchor" id="cu_ssgl_sec_dep_subsec"></a>
Installation and usage</h2>
<p>This example requires the following third-party library :</p><ul>
<li>libpng</li>
<li>cuda (tested with 9.2).</li>
</ul>
<p>To compile and run the example, call </p><div class="fragment"><div class="line">cd build &amp;&amp; make ssgls</div>
<div class="line">cd examples/cuda &amp;&amp; ./ponca_ssgls</div>
</div><!-- fragment --><p>This will takes the two input pictures packed in this example (in "data" directory) and compute the curvature for a screenspace neighborhood 10x10 pixels. </p><div class="image">
<img src="ssgls_input.png" alt=""/>
<div class="caption">
Screen-Space Curvature typical input. Left: world coordinates. Right: remapped normal vectors</div></div>
<p>It will generate this picture </p><div class="image">
<img src="ssgls_result1.png" alt=""/>
<div class="caption">
Screen-Space Curvature estimation</div></div>
<h1><a class="anchor" id="cu_ssgl_cuda_sec"></a>
Cuda programming</h1>
<p>Here are the technical details related to the cuda and C++ biding for screen-space curvature estimation.</p>
<h2><a class="anchor" id="cu_ssgl_cuda_mypoint_sec"></a>
Define fitting data structure</h2>
<div class="fragment"><div class="line">class ScreenSpacePoint</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    enum {Dim = 3};</div>
<div class="line">    typedef float Scalar;</div>
<div class="line">    typedef Eigen::Matrix&lt;Scalar, Dim, 1&gt;   VectorType;</div>
<div class="line">    typedef Eigen::Matrix&lt;Scalar, 2,   1&gt;   ScreenVectorType;</div>
<div class="line">    typedef Eigen::Matrix&lt;Scalar, Dim, Dim&gt; MatrixType;</div>
<div class="line"> </div>
<div class="line">    PONCA_MULTIARCH inline ScreenSpacePoint(const VectorType       &amp;_pos    = VectorType::Zero(),</div>
<div class="line">                                      const VectorType       &amp;_normal = VectorType::Zero(),</div>
<div class="line">                                      const ScreenVectorType &amp;_spos   = ScreenVectorType::Zero())</div>
<div class="line">        : m_pos(_pos), m_normal(_normal), m_spos(_spos){}</div>
<div class="line"> </div>
<div class="line">    PONCA_MULTIARCH inline const VectorType&amp; pos()  const { return m_pos; }</div>
<div class="line">    PONCA_MULTIARCH inline const VectorType&amp; normal()   const { return m_normal; }</div>
<div class="line">    PONCA_MULTIARCH inline const ScreenVectorType&amp; spos() const { return m_spos; }</div>
<div class="line"> </div>
<div class="line">    PONCA_MULTIARCH inline VectorType&amp; pos()     { return m_pos; }</div>
<div class="line">    PONCA_MULTIARCH inline VectorType&amp; normal()  { return m_normal; }</div>
<div class="line">    PONCA_MULTIARCH inline ScreenVectorType&amp; spos() { return m_spos; }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    VectorType  m_pos, m_normal;</div>
<div class="line">    ScreenVectorType m_spos;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="cu_ssgl_cuda_weight_sec"></a>
Define weighting functions</h2>
<div class="fragment"><div class="line">class ProjectedWeightFunc: public Ponca::DistWeightFunc&lt;ScreenSpacePoint,Ponca::SmoothWeightKernel&lt;Scalar&gt; &gt;</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    typedef ScreenSpacePoint::Scalar Scalar;</div>
<div class="line">    typedef ScreenSpacePoint::VectorType VectorType;</div>
<div class="line"> </div>
<div class="line">    PONCA_MULTIARCH inline ProjectedWeightFunc(const Scalar&amp; _t = Scalar(1.), const Scalar _dz = 0.f)</div>
<div class="line">        : Ponca::DistWeightFunc&lt;ScreenSpacePoint,Ponca::SmoothWeightKernel&lt;Scalar&gt; &gt;(_t),</div>
<div class="line">          m_dz(_dz) {}</div>
<div class="line"> </div>
<div class="line">    PONCA_MULTIARCH inline Scalar w(const VectorType&amp; _relativePos, const ScreenSpacePoint&amp;  _attributes) const</div>
<div class="line">    {</div>
<div class="line">        PONCA_MULTIARCH_STD_MATH(abs);</div>
<div class="line">        Scalar d  = _attributes.spos().norm();</div>
<div class="line">        const float dz = abs(_relativePos[2]);</div>
<div class="line">        if (d &gt; m_t || (m_dz != Scalar(0) &amp;&amp; dz &gt; m_dz))</div>
<div class="line">        {</div>
<div class="line">            return Scalar(0.);</div>
<div class="line">        }</div>
<div class="line">        return m_wk.f(d/m_t);</div>
<div class="line">    }</div>
<div class="line">private:</div>
<div class="line">    float m_dz;</div>
<div class="line">};</div>
</div><!-- fragment --> <h2><a class="anchor" id="cu_ssgl_cuda_fit_sec"></a>
Define fitting primitive</h2>
<div class="fragment"><div class="line">typedef Ponca::Basket&lt; ScreenSpacePoint,</div>
<div class="line">                           ProjectedWeightFunc,</div>
<div class="line">                           Ponca::OrientedSphereFit,</div>
<div class="line">                           Ponca::GLSParam&gt; ScreenSpaceFit;</div>
</div><!-- fragment --><h2><a class="anchor" id="cu_ssgl_cuda_kernel_sec"></a>
Kernel</h2>
<div class="fragment"><div class="line">__global__ void doGLS_kernel( int _imgw, int _imgh, int _scale,</div>
<div class="line">            float _maxDepthDiff, float* _positions, float* _normals,</div>
<div class="line">            float* _result)</div>
<div class="line">{</div>
<div class="line">    int tx = threadIdx.x;</div>
<div class="line">    int ty = threadIdx.y;</div>
<div class="line">    int bw = blockDim.x;</div>
<div class="line">    int bh = blockDim.y;</div>
<div class="line">    int x = blockIdx.x * bw + tx;</div>
<div class="line">    int y = blockIdx.y * bh + ty;</div>
<div class="line"> </div>
<div class="line">    int idx = y * _imgw + x;</div>
<div class="line"> </div>
<div class="line">    if((x &gt;= _imgw || y &gt;= _imgh))</div>
<div class="line">    {</div>
<div class="line">            return;</div>
<div class="line">    }</div>
<div class="line">    else if(getVector(x, y, _imgw, _imgh, _normals).squaredNorm() == 0.f)</div>
<div class="line">    {</div>
<div class="line">    _result[idx] = 0.f;</div>
<div class="line">            return;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    VectorType one = VectorType::Ones();</div>
<div class="line">    const float scale2 = float(_scale * _scale);</div>
<div class="line"> </div>
<div class="line">//    VectorType vvvvv = getVector(x, y, _imgw, _imgh, _positions);</div>
<div class="line">//    VectorType nnnnn = getVector(x, y, _imgw, _imgh, _normals);</div>
<div class="line">//    _result[idx] = vvvvv(2);</div>
<div class="line">//    return;</div>
<div class="line"> </div>
<div class="line">    ScreenSpaceFit fit;</div>
<div class="line">    fit.init(getVector(x, y, _imgw, _imgh, _positions) * 2.f - one);</div>
<div class="line">    fit.setWeightFunc(ProjectedWeightFunc(_scale, _maxDepthDiff));</div>
<div class="line"> </div>
<div class="line">    _result[idx] = 0.f;</div>
<div class="line"> </div>
<div class="line">    // collect neighborhood</div>
<div class="line">    for(int dy = -_scale; dy != _scale + 1; dy++)</div>
<div class="line">    {</div>
<div class="line">        for(int dx = -_scale; dx != _scale + 1; dx++)</div>
<div class="line">        {</div>
<div class="line">            float dist2 = dy*dy + dx*dx;</div>
<div class="line">            // Check if we are in the circular screen-space neighborhood</div>
<div class="line">            if (dist2 &lt; scale2)</div>
<div class="line">            {</div>
<div class="line">                int nx, ny; // neighbor ids</div>
<div class="line"> </div>
<div class="line">    nx = x + dx;</div>
<div class="line">    ny = y + dy;</div>
<div class="line"> </div>
<div class="line">    // Check image boundaries</div>
<div class="line">    if(nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; _imgw &amp;&amp; ny &lt; _imgh)</div>
<div class="line">    {</div>
<div class="line">        ScreenSpacePoint::VectorType n = getVector(nx, ny, _imgw, _imgh, _normals);</div>
<div class="line">        // add nei only when the normal is properly defined</div>
<div class="line">        if(n.squaredNorm() != 0.f)</div>
<div class="line">        {</div>
<div class="line">      // RGB to XYZ remapping</div>
<div class="line">      n =  2.f * n - one;</div>
<div class="line">      n.normalize();</div>
<div class="line"> </div>
<div class="line">      ScreenSpacePoint::ScreenVectorType xyCoord;</div>
<div class="line">      xyCoord[0] = dx;</div>
<div class="line">      xyCoord[1] = dy;</div>
<div class="line"> </div>
<div class="line">      ScreenSpacePoint::VectorType p = getVector(nx, ny, _imgw, _imgh, _positions) * 2.f - one;</div>
<div class="line">      // GLS computation</div>
<div class="line">      fit.addNeighbor(ScreenSpacePoint(p, n, xyCoord));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // closed form minimization</div>
<div class="line">    fit.finalize();</div>
<div class="line">    _result[idx] = fit.kappa();</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="cu_ssgl_cuda_access_sec"></a>
Memory access</h2>
<p>We format the input data, filled by dimension (in object space) and then by the screen-space coordinates: </p><div class="fragment"><div class="line">__device__ int getId(const int _x,</div>
<div class="line">                     const int _y,</div>
<div class="line">                     const int _width,</div>
<div class="line">                     const int _height,</div>
<div class="line">                     const int _component,</div>
<div class="line">                     const int _nbComponent)</div>
<div class="line">{</div>
<div class="line">    return (_component) + _nbComponent*(_x + _y * _width);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__device__ VectorType getVector(const int _x,</div>
<div class="line">                                const int _y,</div>
<div class="line">                                const int _width,</div>
<div class="line">                                const int _height,</div>
<div class="line">                                const float* _buffer)</div>
<div class="line">{</div>
<div class="line">    VectorType r;</div>
<div class="line">    r &lt;&lt; Scalar(_buffer[getId(_x,_y,_width,_height,0,3)]),</div>
<div class="line">        Scalar(_buffer[getId(_x,_y,_width,_height,1,3)]),</div>
<div class="line">        Scalar(_buffer[getId(_x,_y,_width,_height,2,3)]);</div>
<div class="line">    return r;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="cu_ssgl_sec"></a>
The whole code</h1>
<p>We use freeimageplus to format input data.</p>
<div class="fragment"><div class="line">/*</div>
<div class="line">This Source Code Form is subject to the terms of the Mozilla Public</div>
<div class="line">License, v. 2.0. If a copy of the MPL was not distributed with this</div>
<div class="line">file, You can obtain one at http://mozilla.org/MPL/2.0/.</div>
<div class="line">*/</div>
<div class="line"> </div>
<div class="line">/*!</div>
<div class="line">\file examples/Ponca/ssgls.cu</div>
<div class="line">\brief Screen space GLS using c++/CUDA</div>
<div class="line">*/</div>
<div class="line"> </div>
<div class="line">#include &lt;stdio.h&gt;</div>
<div class="line">#include &lt;stdlib.h&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;cmath&gt;</div>
<div class="line">#include &lt;algorithm&gt;</div>
<div class="line">#include &lt;vector&gt;</div>
<div class="line">#include &lt;chrono&gt;</div>
<div class="line"> </div>
<div class="line">#include &lt;png.h&gt;</div>
<div class="line"> </div>
<div class="line">#define EIGEN_DEFAULT_DENSE_INDEX_TYPE int</div>
<div class="line"> </div>
<div class="line">#include &lt;Ponca/src/Fitting/basket.h&gt;</div>
<div class="line">#include &lt;Ponca/src/Fitting/gls.h&gt;</div>
<div class="line">#include &lt;Ponca/src/Fitting/orientedSphereFit.h&gt;</div>
<div class="line">#include &lt;Ponca/src/Fitting/weightFunc.h&gt;</div>
<div class="line">#include &lt;Ponca/src/Fitting/weightKernel.h&gt;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">/**************************************************************************************************/</div>
<div class="line">/* IO (source: http://zarb.org/~gc/html/libpng.html )                                             */</div>
<div class="line">/**************************************************************************************************/</div>
<div class="line"> </div>
<div class="line">class PNGImage</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">  inline bool load(const char *file_name);</div>
<div class="line">  inline bool loaded () const { return ! row_pointers.empty(); }</div>
<div class="line">  inline bool save(const char *file_name);</div>
<div class="line"> </div>
<div class="line">  inline png_uint_32 width()  const { return m_width; };</div>
<div class="line">  inline png_uint_32 height() const { return m_height; };</div>
<div class="line"> </div>
<div class="line">  inline const std::vector&lt;png_bytep&gt;&amp; buffer() const { return row_pointers; }</div>
<div class="line">  inline std::vector&lt;png_bytep&gt;&amp; buffer() { return row_pointers; }</div>
<div class="line">  inline png_byte colorType() const { return png_get_color_type(png_ptr, info_ptr);}</div>
<div class="line"> </div>
<div class="line">  ~PNGImage() { for (auto e: row_pointers) delete e; row_pointers.clear(); }</div>
<div class="line">private:</div>
<div class="line">  png_uint_32 m_width, m_height;</div>
<div class="line">  png_byte color_type;</div>
<div class="line">  png_byte bit_depth;</div>
<div class="line"> </div>
<div class="line">  png_structp png_ptr;</div>
<div class="line">  png_infop info_ptr;</div>
<div class="line">  int number_of_passes;</div>
<div class="line">  std::vector&lt;png_bytep&gt; row_pointers;</div>
<div class="line"> </div>
<div class="line">  using vecSizeT = typename std::vector&lt;png_bytep&gt;::size_type;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">bool</div>
<div class="line">PNGImage::load(const char* file_name)</div>
<div class="line">{</div>
<div class="line">    unsigned char header[8];    // 8 is the maximum size that can be checked</div>
<div class="line"> </div>
<div class="line">    /* open file and test for it being a png */</div>
<div class="line">    FILE *fp = fopen(file_name, &quot;rb&quot;);</div>
<div class="line">    if (!fp)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; &quot;[read_png_file] File &quot; \</div>
<div class="line">                  &lt;&lt;  file_name</div>
<div class="line">                  &lt;&lt; &quot; could not be opened for reading&quot;</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">        return false;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    fread(header, 1, 8, fp);</div>
<div class="line">    if (png_sig_cmp(header, 0, 8))</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; &quot;[read_png_file] File &quot; \</div>
<div class="line">                  &lt;&lt;  file_name</div>
<div class="line">                  &lt;&lt; &quot; is not recognized as a PNG file&quot;</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">        return false;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    /* initialize stuff */</div>
<div class="line">    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, nullptr, nullptr, nullptr);</div>
<div class="line"> </div>
<div class="line">    if (!png_ptr)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; &quot;[read_png_file] png_create_read_struct failed&quot;</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">        return false;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    info_ptr = png_create_info_struct(png_ptr);</div>
<div class="line">    if (!info_ptr)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; &quot;[read_png_file] png_create_info_struct failed&quot;</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">        return false;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if (setjmp(png_jmpbuf(png_ptr)))</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; &quot;[read_png_file] Error during init_iod&quot;</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">        return false;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    png_init_io(png_ptr, fp);</div>
<div class="line">    png_set_sig_bytes(png_ptr, 8);</div>
<div class="line"> </div>
<div class="line">    png_read_info(png_ptr, info_ptr);</div>
<div class="line"> </div>
<div class="line">    m_width = png_get_image_width(png_ptr, info_ptr);</div>
<div class="line">    m_height = png_get_image_height(png_ptr, info_ptr);</div>
<div class="line">    color_type = png_get_color_type(png_ptr, info_ptr);</div>
<div class="line">    bit_depth = png_get_bit_depth(png_ptr, info_ptr);</div>
<div class="line"> </div>
<div class="line">    number_of_passes = png_set_interlace_handling(png_ptr);</div>
<div class="line">    png_read_update_info(png_ptr, info_ptr);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    /* read file */</div>
<div class="line">    if (setjmp(png_jmpbuf(png_ptr)))</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; &quot;[read_png_file] Error during read_image&quot;</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">        return false;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    row_pointers.resize( m_height );</div>
<div class="line">    for (vecSizeT y=0; y&lt; vecSizeT(m_height); y++)</div>
<div class="line">      row_pointers[y] = (png_byte*) (malloc(png_get_rowbytes(png_ptr,info_ptr)));</div>
<div class="line"> </div>
<div class="line">    png_read_image(png_ptr, row_pointers.data());</div>
<div class="line"> </div>
<div class="line">    fclose(fp);</div>
<div class="line"> </div>
<div class="line">    return true;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">bool</div>
<div class="line">PNGImage::save(const char* file_name) {</div>
<div class="line">  /* create file */</div>
<div class="line">  FILE *fp = fopen(file_name, &quot;wb&quot;);</div>
<div class="line">  if (!fp)</div>
<div class="line">  {</div>
<div class="line">      std::cerr &lt;&lt; &quot;[write_png_file] File &quot; \</div>
<div class="line">                &lt;&lt;  file_name</div>
<div class="line">                &lt;&lt; &quot; could not be opened for reading&quot;</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      return false;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  /* initialize stuff */</div>
<div class="line">  png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, nullptr, nullptr, nullptr);</div>
<div class="line"> </div>
<div class="line">  if (!png_ptr)</div>
<div class="line">  {</div>
<div class="line">      std::cerr &lt;&lt; &quot;[write_png_file] png_create_write_struct failed&quot;</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      return false;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  info_ptr = png_create_info_struct(png_ptr);</div>
<div class="line">  if (!info_ptr)</div>
<div class="line">  {</div>
<div class="line">      std::cerr &lt;&lt; &quot;[write_png_file] png_create_info_struct failed&quot;</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      return false;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  if (setjmp(png_jmpbuf(png_ptr)))</div>
<div class="line">  {</div>
<div class="line">      std::cerr &lt;&lt; &quot;[write_png_file] Error during init_io&quot;</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      return false;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  png_init_io(png_ptr, fp);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  /* write header */</div>
<div class="line">  if (setjmp(png_jmpbuf(png_ptr)))</div>
<div class="line">  {</div>
<div class="line">      std::cerr &lt;&lt; &quot;[write_png_file] Error during writing header&quot;</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      return false;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  png_set_IHDR(png_ptr, info_ptr, m_width, m_height,</div>
<div class="line">               bit_depth, color_type, PNG_INTERLACE_NONE,</div>
<div class="line">               PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);</div>
<div class="line"> </div>
<div class="line">  png_write_info(png_ptr, info_ptr);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  /* write bytes */</div>
<div class="line">  if (setjmp(png_jmpbuf(png_ptr)))</div>
<div class="line">  {</div>
<div class="line">      std::cerr &lt;&lt; &quot;[write_png_file] Error during writing bytes&quot;</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      return false;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  png_write_image(png_ptr, row_pointers.data());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  /* end write */</div>
<div class="line">  if (setjmp(png_jmpbuf(png_ptr)))</div>
<div class="line">  {</div>
<div class="line">      std::cerr &lt;&lt; &quot;[write_png_file] Error during end of write&quot;</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      return false;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  png_write_end(png_ptr, nullptr);</div>
<div class="line"> </div>
<div class="line">  fclose(fp);</div>
<div class="line">  return true;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**************************************************************************************************/</div>
<div class="line">/* Ponca initialization                                                                           */</div>
<div class="line">/**************************************************************************************************/</div>
<div class="line">//! [mypoint]</div>
<div class="line">class ScreenSpacePoint</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    enum {Dim = 3};</div>
<div class="line">    typedef float Scalar;</div>
<div class="line">    typedef Eigen::Matrix&lt;Scalar, Dim, 1&gt;   VectorType;</div>
<div class="line">    typedef Eigen::Matrix&lt;Scalar, 2,   1&gt;   ScreenVectorType;</div>
<div class="line">    typedef Eigen::Matrix&lt;Scalar, Dim, Dim&gt; MatrixType;</div>
<div class="line"> </div>
<div class="line">    PONCA_MULTIARCH inline ScreenSpacePoint(const VectorType       &amp;_pos    = VectorType::Zero(),</div>
<div class="line">                                      const VectorType       &amp;_normal = VectorType::Zero(),</div>
<div class="line">                                      const ScreenVectorType &amp;_spos   = ScreenVectorType::Zero())</div>
<div class="line">        : m_pos(_pos), m_normal(_normal), m_spos(_spos){}</div>
<div class="line"> </div>
<div class="line">    PONCA_MULTIARCH inline const VectorType&amp; pos()  const { return m_pos; }</div>
<div class="line">    PONCA_MULTIARCH inline const VectorType&amp; normal()   const { return m_normal; }</div>
<div class="line">    PONCA_MULTIARCH inline const ScreenVectorType&amp; spos() const { return m_spos; }</div>
<div class="line"> </div>
<div class="line">    PONCA_MULTIARCH inline VectorType&amp; pos()     { return m_pos; }</div>
<div class="line">    PONCA_MULTIARCH inline VectorType&amp; normal()  { return m_normal; }</div>
<div class="line">    PONCA_MULTIARCH inline ScreenVectorType&amp; spos() { return m_spos; }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    VectorType  m_pos, m_normal;</div>
<div class="line">    ScreenVectorType m_spos;</div>
<div class="line">};</div>
<div class="line">//! [mypoint]</div>
<div class="line"> </div>
<div class="line">typedef ScreenSpacePoint::Scalar Scalar;</div>
<div class="line">typedef ScreenSpacePoint::VectorType VectorType;</div>
<div class="line">typedef ScreenSpacePoint::ScreenVectorType ScreenVectorType;</div>
<div class="line"> </div>
<div class="line">//! [w_def]</div>
<div class="line">class ProjectedWeightFunc: public Ponca::DistWeightFunc&lt;ScreenSpacePoint,Ponca::SmoothWeightKernel&lt;Scalar&gt; &gt;</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    typedef ScreenSpacePoint::Scalar Scalar;</div>
<div class="line">    typedef ScreenSpacePoint::VectorType VectorType;</div>
<div class="line"> </div>
<div class="line">    PONCA_MULTIARCH inline ProjectedWeightFunc(const Scalar&amp; _t = Scalar(1.), const Scalar _dz = 0.f)</div>
<div class="line">        : Ponca::DistWeightFunc&lt;ScreenSpacePoint,Ponca::SmoothWeightKernel&lt;Scalar&gt; &gt;(_t),</div>
<div class="line">          m_dz(_dz) {}</div>
<div class="line"> </div>
<div class="line">    PONCA_MULTIARCH inline Scalar w(const VectorType&amp; _relativePos, const ScreenSpacePoint&amp;  _attributes) const</div>
<div class="line">    {</div>
<div class="line">        PONCA_MULTIARCH_STD_MATH(abs);</div>
<div class="line">        Scalar d  = _attributes.spos().norm();</div>
<div class="line">        const float dz = abs(_relativePos[2]);</div>
<div class="line">        if (d &gt; m_t || (m_dz != Scalar(0) &amp;&amp; dz &gt; m_dz))</div>
<div class="line">        {</div>
<div class="line">            return Scalar(0.);</div>
<div class="line">        }</div>
<div class="line">        return m_wk.f(d/m_t);</div>
<div class="line">    }</div>
<div class="line">private:</div>
<div class="line">    float m_dz;</div>
<div class="line">};</div>
<div class="line">//! [w_def]</div>
<div class="line"> </div>
<div class="line">//! [fit_def]</div>
<div class="line">typedef Ponca::Basket&lt; ScreenSpacePoint,</div>
<div class="line">                           ProjectedWeightFunc,</div>
<div class="line">                           Ponca::OrientedSphereFit,</div>
<div class="line">                           Ponca::GLSParam&gt; ScreenSpaceFit;</div>
<div class="line">//! [fit_def]</div>
<div class="line"> </div>
<div class="line">//! [data_acces]</div>
<div class="line">__device__ int getId(const int _x,</div>
<div class="line">                     const int _y,</div>
<div class="line">                     const int _width,</div>
<div class="line">                     const int _height,</div>
<div class="line">                     const int _component,</div>
<div class="line">                     const int _nbComponent)</div>
<div class="line">{</div>
<div class="line">    return (_component) + _nbComponent*(_x + _y * _width);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__device__ VectorType getVector(const int _x,</div>
<div class="line">                                const int _y,</div>
<div class="line">                                const int _width,</div>
<div class="line">                                const int _height,</div>
<div class="line">                                const float* _buffer)</div>
<div class="line">{</div>
<div class="line">    VectorType r;</div>
<div class="line">    r &lt;&lt; Scalar(_buffer[getId(_x,_y,_width,_height,0,3)]),</div>
<div class="line">        Scalar(_buffer[getId(_x,_y,_width,_height,1,3)]),</div>
<div class="line">        Scalar(_buffer[getId(_x,_y,_width,_height,2,3)]);</div>
<div class="line">    return r;</div>
<div class="line">}</div>
<div class="line">//! [data_acces]</div>
<div class="line"> </div>
<div class="line">//! [kernel]</div>
<div class="line">__global__ void doGLS_kernel( int _imgw, int _imgh, int _scale,</div>
<div class="line">            float _maxDepthDiff, float* _positions, float* _normals,</div>
<div class="line">            float* _result)</div>
<div class="line">{</div>
<div class="line">    int tx = threadIdx.x;</div>
<div class="line">    int ty = threadIdx.y;</div>
<div class="line">    int bw = blockDim.x;</div>
<div class="line">    int bh = blockDim.y;</div>
<div class="line">    int x = blockIdx.x * bw + tx;</div>
<div class="line">    int y = blockIdx.y * bh + ty;</div>
<div class="line"> </div>
<div class="line">    int idx = y * _imgw + x;</div>
<div class="line"> </div>
<div class="line">    if((x &gt;= _imgw || y &gt;= _imgh))</div>
<div class="line">    {</div>
<div class="line">            return;</div>
<div class="line">    }</div>
<div class="line">    else if(getVector(x, y, _imgw, _imgh, _normals).squaredNorm() == 0.f)</div>
<div class="line">    {</div>
<div class="line">    _result[idx] = 0.f;</div>
<div class="line">            return;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    VectorType one = VectorType::Ones();</div>
<div class="line">    const float scale2 = float(_scale * _scale);</div>
<div class="line"> </div>
<div class="line">//    VectorType vvvvv = getVector(x, y, _imgw, _imgh, _positions);</div>
<div class="line">//    VectorType nnnnn = getVector(x, y, _imgw, _imgh, _normals);</div>
<div class="line">//    _result[idx] = vvvvv(2);</div>
<div class="line">//    return;</div>
<div class="line"> </div>
<div class="line">    ScreenSpaceFit fit;</div>
<div class="line">    fit.init(getVector(x, y, _imgw, _imgh, _positions) * 2.f - one);</div>
<div class="line">    fit.setWeightFunc(ProjectedWeightFunc(_scale, _maxDepthDiff));</div>
<div class="line"> </div>
<div class="line">    _result[idx] = 0.f;</div>
<div class="line"> </div>
<div class="line">    // collect neighborhood</div>
<div class="line">    for(int dy = -_scale; dy != _scale + 1; dy++)</div>
<div class="line">    {</div>
<div class="line">        for(int dx = -_scale; dx != _scale + 1; dx++)</div>
<div class="line">        {</div>
<div class="line">            float dist2 = dy*dy + dx*dx;</div>
<div class="line">            // Check if we are in the circular screen-space neighborhood</div>
<div class="line">            if (dist2 &lt; scale2)</div>
<div class="line">            {</div>
<div class="line">                int nx, ny; // neighbor ids</div>
<div class="line"> </div>
<div class="line">    nx = x + dx;</div>
<div class="line">    ny = y + dy;</div>
<div class="line"> </div>
<div class="line">    // Check image boundaries</div>
<div class="line">    if(nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; _imgw &amp;&amp; ny &lt; _imgh)</div>
<div class="line">    {</div>
<div class="line">        ScreenSpacePoint::VectorType n = getVector(nx, ny, _imgw, _imgh, _normals);</div>
<div class="line">        // add nei only when the normal is properly defined</div>
<div class="line">        if(n.squaredNorm() != 0.f)</div>
<div class="line">        {</div>
<div class="line">      // RGB to XYZ remapping</div>
<div class="line">      n =  2.f * n - one;</div>
<div class="line">      n.normalize();</div>
<div class="line"> </div>
<div class="line">      ScreenSpacePoint::ScreenVectorType xyCoord;</div>
<div class="line">      xyCoord[0] = dx;</div>
<div class="line">      xyCoord[1] = dy;</div>
<div class="line"> </div>
<div class="line">      ScreenSpacePoint::VectorType p = getVector(nx, ny, _imgw, _imgh, _positions) * 2.f - one;</div>
<div class="line">      // GLS computation</div>
<div class="line">      fit.addNeighbor(ScreenSpacePoint(p, n, xyCoord));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // closed form minimization</div>
<div class="line">    fit.finalize();</div>
<div class="line">    _result[idx] = fit.kappa();</div>
<div class="line">}</div>
<div class="line">//! [kernel]</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line">* \brief RGB basic color representation</div>
<div class="line">*/</div>
<div class="line">typedef struct</div>
<div class="line">{</div>
<div class="line">    double r,g,b;</div>
<div class="line">}Color;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line">* \brief Return Color corresponding to the _value param. Simulating a &quot;seismic&quot; like color map</div>
<div class="line">*/</div>
<div class="line">__host__ Color getColor(float _value, float _valueMin, float _valueMax)</div>
<div class="line">{</div>
<div class="line">    Color c = {1.0, 1.0, 1.0};</div>
<div class="line">    double dv;</div>
<div class="line"> </div>
<div class="line">    // Unknown values in our kernel</div>
<div class="line">    if(_value == 0.)</div>
<div class="line">    {</div>
<div class="line">        return c;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Threshold</div>
<div class="line">    if (_value &lt; _valueMin)</div>
<div class="line">    {</div>
<div class="line">        _value = _valueMin;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if (_value &gt; _valueMax)</div>
<div class="line">    {</div>
<div class="line">        _value = _valueMax;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Interval</div>
<div class="line">    dv = _valueMax - _valueMin;</div>
<div class="line"> </div>
<div class="line">    // Seismic color map like</div>
<div class="line">    if(_value &lt; (_valueMin + 0.5 * dv))</div>
<div class="line">    {</div>
<div class="line">        c.r = 2 * (_value - _valueMin) / dv;</div>
<div class="line">        c.g = 2 * (_value - _valueMin) / dv;</div>
<div class="line">        c.b = 1;</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">    {</div>
<div class="line">        c.b = 2 - 2 * (_value - _valueMin) / dv;</div>
<div class="line">        c.g = 2 - 2 * (_value - _valueMin) / dv;</div>
<div class="line">        c.r = 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return c;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line">* \brief Init input datas to be used on host</div>
<div class="line">*/</div>
<div class="line">__host__ bool initInputDatas(const PNGImage&amp; positions, const PNGImage&amp; normals,</div>
<div class="line">                             std::vector&lt;float&gt;&amp; positionsInfos,</div>
<div class="line">                             std::vector&lt;float&gt;&amp; normalsInfos,</div>
<div class="line">                             unsigned int&amp; width, unsigned int&amp; height)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    if (positions.colorType() != PNG_COLOR_TYPE_RGB) {</div>
<div class="line">      std::cerr &lt;&lt; &quot;[process_file] color_type of input file must be PNG_COLOR_TYPE_RGB (&quot;</div>
<div class="line">                &lt;&lt; PNG_COLOR_TYPE_RGB</div>
<div class="line">                &lt;&lt; &quot;) (is &quot;</div>
<div class="line">                &lt;&lt; positions.colorType()</div>
<div class="line">                &lt;&lt; &quot;)&quot;</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      return false;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    width = positions.width();</div>
<div class="line">    height = positions.height();</div>
<div class="line"> </div>
<div class="line">    positionsInfos.resize(width*height*3);</div>
<div class="line">    normalsInfos.resize(width*height*3);</div>
<div class="line"> </div>
<div class="line">    auto pbuf = positions.buffer();</div>
<div class="line">    auto nbuf = normals.buffer();</div>
<div class="line"> </div>
<div class="line">    for (int j = 0; j &lt; height; ++j) {</div>
<div class="line">        png_bytep pcol = pbuf[j];</div>
<div class="line">        png_bytep ncol = nbuf[j];</div>
<div class="line"> </div>
<div class="line">        float* pout = positionsInfos.data()+j*width*3;</div>
<div class="line">        float* nout = normalsInfos.data()+j*width*3;</div>
<div class="line"> </div>
<div class="line">        auto scaleValues = [](const png_byte&amp; in){ return in / 255.f * 2.f - 1.f; };</div>
<div class="line">        std::transform(pcol, pcol+width*3, pout, scaleValues );</div>
<div class="line">        std::transform(ncol, ncol+width*3, nout, scaleValues );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return true;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line">* \brief Save _results into png image</div>
<div class="line">*/</div>
<div class="line">__host__ bool saveResult(float* _results,</div>
<div class="line">                         const char* _positionsFilename, const char* _resultFilename)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    PNGImage result;</div>
<div class="line">    if(!result.load(_positionsFilename))</div>
<div class="line">    {</div>
<div class="line">        fprintf(stderr, &quot;Cannot load positions\n&quot;);</div>
<div class="line">        return false;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    int width = result.width();</div>
<div class="line">    int height = result.height();</div>
<div class="line"> </div>
<div class="line">    auto pbuf = result.buffer().data();</div>
<div class="line"> </div>
<div class="line">    for (int j = 0; j &lt; height; ++j) {</div>
<div class="line">        float* pin = _results+j*width;</div>
<div class="line">        png_bytep col = pbuf[j];</div>
<div class="line">        for (int i = 0; i &lt; width; ++i) {</div>
<div class="line">            //check nan</div>
<div class="line">            if(std::isnan(pin[i]))</div>
<div class="line">            {</div>
<div class="line">                pin[i] = 0.f;</div>
<div class="line">            }</div>
<div class="line">            Color c = getColor(pin[i], -10., 10.);</div>
<div class="line"> </div>
<div class="line">            col[i * 3 + 0] = c.r * 255.;</div>
<div class="line">            col[i * 3 + 1] = c.g * 255.;</div>
<div class="line">            col[i * 3 + 2] = c.b * 255.;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if(!result.save(_resultFilename))</div>
<div class="line">    {</div>
<div class="line">        fprintf(stderr, &quot;Cannot save image\n&quot;);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return true;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__host__ int adjust(int n, int blockSize)</div>
<div class="line">{</div>
<div class="line">   if (n &lt; blockSize) { return n; }</div>
<div class="line">   return (n / blockSize + (n % blockSize == 0 ? 0 : 1)) * blockSize;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    const char *positionsFilename = &quot;./data/ssgls_sample_wc.png&quot;;</div>
<div class="line">    const char *normalsFilename = &quot;./data/ssgls_sample_normal.png&quot;;</div>
<div class="line">    const char *resultFilename = &quot;./ssgls_results.png&quot;;</div>
<div class="line"> </div>
<div class="line">    PNGImage positions, normals;</div>
<div class="line"> </div>
<div class="line">    if(!positions.load(positionsFilename) || ! normals.load(normalsFilename))</div>
<div class="line">    {</div>
<div class="line">        return 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    float fScale = 10.f;</div>
<div class="line">    float fMaxDepthDiff = 0.00f;</div>
<div class="line">    unsigned int width = 0;</div>
<div class="line">    unsigned int height = 0;</div>
<div class="line">    std::vector&lt;float&gt; positionsInfos, normalsInfos;</div>
<div class="line"> </div>
<div class="line">    if(!initInputDatas(positions, normals, positionsInfos, normalsInfos, width, height))</div>
<div class="line">    {</div>
<div class="line">        return 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Image size : &quot; &lt;&lt; width &lt;&lt; &quot;*&quot; &lt;&lt; height &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    /*********** Init Output ************/</div>
<div class="line">    float *results = new float[width*height];</div>
<div class="line">    std::fill( results, results + width*height, 0.f );</div>
<div class="line"> </div>
<div class="line">    /************* Init device mem *************/</div>
<div class="line">    size_t sizeResults = width * height * sizeof(float);</div>
<div class="line">    size_t sizeImg = width * height * 3 * sizeof(float);</div>
<div class="line"> </div>
<div class="line">    float* positionsInfos_device;</div>
<div class="line">    float* normalsInfos_device;</div>
<div class="line">    float* results_device;</div>
<div class="line"> </div>
<div class="line">    cudaMalloc(&amp;positionsInfos_device, sizeImg);</div>
<div class="line">    cudaMemcpy(positionsInfos_device, positionsInfos.data(), sizeImg, cudaMemcpyHostToDevice);</div>
<div class="line"> </div>
<div class="line">    cudaMalloc(&amp;normalsInfos_device, sizeImg);</div>
<div class="line">    cudaMemcpy(normalsInfos_device, normalsInfos.data(), sizeImg, cudaMemcpyHostToDevice);</div>
<div class="line"> </div>
<div class="line">    cudaMalloc(&amp;results_device, sizeResults);</div>
<div class="line">    cudaMemcpy(results_device, results, sizeResults, cudaMemcpyHostToDevice);</div>
<div class="line"> </div>
<div class="line">    cudaError_t err = cudaGetLastError();</div>
<div class="line">    /************* Memory conf *************/</div>
<div class="line"> </div>
<div class="line">    // calculate grid size</div>
<div class="line">    dim3 block(32, 32, 1);</div>
<div class="line">    dim3 grid(adjust(width, block.x) / block.x, adjust(height, block.y) / block.y, 1);</div>
<div class="line"> </div>
<div class="line">    /************* Kernel Call *************/</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;ssCurvature running...&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    // dry run: first call is always slower</div>
<div class="line">    doGLS_kernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(width, height, fScale, fMaxDepthDiff, positionsInfos_device, normalsInfos_device, results_device);</div>
<div class="line"> </div>
<div class="line">    int nbrun = 100;</div>
<div class="line">    auto start = std::chrono::system_clock::now();</div>
<div class="line">    for( int i = 0; i != nbrun; ++i) {</div>
<div class="line">      doGLS_kernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(width, height, fScale, fMaxDepthDiff, positionsInfos_device, normalsInfos_device, results_device);</div>
<div class="line">      cudaThreadSynchronize();  // Wait for the GPU launched work to complete</div>
<div class="line">    }</div>
<div class="line">    auto end = std::chrono::system_clock::now();</div>
<div class="line">    std::chrono::duration&lt;double&gt; diff = (end-start)/double(nbrun);</div>
<div class="line"> </div>
<div class="line">    err = cudaGetLastError();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;ssCurvature completed in &quot; &lt;&lt; diff.count() &lt;&lt; &quot; s&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    /************* Get Results *************/</div>
<div class="line">    cudaMemcpy(results, results_device, sizeResults, cudaMemcpyDeviceToHost);</div>
<div class="line"> </div>
<div class="line">    err = cudaGetLastError();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Finalizing...&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    /********** Cuda Free ************/</div>
<div class="line">    cudaFree(positionsInfos_device);</div>
<div class="line">    cudaFree(normalsInfos_device);</div>
<div class="line">    cudaFree(results_device);</div>
<div class="line"> </div>
<div class="line">    err = cudaGetLastError();</div>
<div class="line"> </div>
<div class="line">    /********** Saving _result ************/</div>
<div class="line">    if(!saveResult(results, positionsFilename, resultFilename))</div>
<div class="line">    {</div>
<div class="line">        return 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    /********** Free Memory *********/</div>
<div class="line">    delete [] results;</div>
<div class="line"> </div>
<div class="line">    cudaDeviceReset();</div>
<div class="line">    err = cudaGetLastError();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Finished !&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 4 2021 09:58:14 for Ponca by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
