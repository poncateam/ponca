/*!

  \brief Grenaille: the simplest way to fit and analyze point-sets efficiently.

  This Patate is based on top of Eigen, and use advanced C++ template 
  programming to define generic fitting procedures and analysis.

  In this documentation we present an \ref grenaille_overview_sec of 
  the Grenaille programming concept, as well as a simple 
  \ref grenaille_howto_sec. For a complete example, please go to the
  \ref cpp/grenaille_basic_cpu.cpp "basic_cpu" example.

  \section grenaille_overview_sec Overview

  In Grenaille, you have access to Fitting Kernels and Extensions you can 
  combine using the \ref Basket template class to generate a specialized 
  fitting or analysis kernel:
  \image html grenaille/concept.svg

  \subsection grenaille_overview_basket_sec Basket
  \ref Basket "Basket <class Point, class Weight, class Fit, Ext-set ...>" 
  is an helper template class that you will specialize to define 
  the structure of the targeted kernel. To do so, please consider each of its 
  template parameters:
    - <b>Point</b>: defines the type of data the kernel will be applied on (e.g. number
  of dimensions, attributes),
    - <b>Weight</b>: defines the weighting function that will be applied to collect
  neighbors for the fit,
    - <b>Fit</b>: the fitting kernel. Must implement the Concept::FittingProcedureConcept.
    - <b>Ext-set</b>: set of extensions that will be applied over the fit to
  obtain the desired behavior. Must implement the Concept::FittingExtensionConcept.

  In practice, you will have to define a Point class (you could use the example below
  as basis), a weighting function (most of the time you could use those provided in 
  Grenaille), choose your fitting kernel and the associated extensions. The Concept
  of your class Point is defined by the requirements of the weighting, fitting and 
  extension classes.

  An example of Basket, to fit spheres on oriented point-sets and compute the GLS 
  descriptor:
  \code
  typedef Basket<MyPoint,WeightFunc,OrientedSphereFit, GLSParam> Fit;
  \endcode

  \section grenaille_howto_sec How to

  \subsection grenaille_howto_point_sec Point

  You must implemente the following Concept to write your Point class:
    - Define a public enum value called Dim, to define the number of dimensions:
  \code
enum {Dim = 3};
  \endcode
    - Define a public Scalar type:
  \code
typedef float Scalar; //use floating precision
  \endcode
    - Define a public Vector type. It is strongly recommended to use an Eigen type:
  \code
typedef Eigen::Matrix<Scalar, Dim, 1> VectorType;
  \endcode
    - Provide an implicit constructor,
    - Provide at least a position vector, with r/w accessors:
  \code
  MULTIARCH const VectorType& pos()const;
  MULTIARCH       VectorType& pos();
  \endcode
  
  Example of a minimal class:
  \code
class MyPoint{
public:
  enum {Dim = 3};
  typedef float Scalar;
  typedef Eigen::Matrix<Scalar, Dim, 1> VectorType;

  MULTIARCH inline MyPoint(const VectorType &pos    = VectorType::Zero())
    : _pos(pos) {}
    
  MULTIARCH inline const VectorType& pos()    const { return _pos; }  
  MULTIARCH inline VectorType& pos()    { return _pos; }  

private:
  VectorType _pos;
};
  \endcode

  The other requirements defined by the \ref Basket specialization are listed 
  in the documentation of each used class (Weigthing function, fit or 
  extension). The following sections present at least these requirements for 
  the common cases.

  \subsection grenaille_howto_fit_sec Fitting kernel

  A fitting kernel define at least four methods:
  \code
// init
MULTIARCH void setWeightFunc (const WeightFunc& w);
MULTIARCH void init (const VectorType& evalPos);

// processing
MULTIARCH void addNeighbor(const Point &nei);
MULTIARCH void finalize   ();
  \endcode
  
  This Concept is resumed in the documentation of 
  Concept::FittingProcedureConcept.

  Please go to the documentation of each fitting primitive to know their 
  requirements. For example, \ref OrientedSphereFit requires to define
  a normal vector and the associated accessors in the Point class:
  \code
class MyPoint{
public:
  enum {Dim = 3};
  typedef float Scalar;
  typedef Eigen::Matrix<Scalar, Dim, 1> VectorType;

  MULTIARCH inline MyPoint(const VectorType &pos    = VectorType::Zero(), 
		 const VectorType& normal = VectorType::Zero())
    : _pos(pos), _normal(normal) {}
    
  MULTIARCH inline const VectorType& pos()    const { return _pos; }  
  MULTIARCH inline const VectorType& normal() const { return _normal; }

  MULTIARCH inline VectorType& pos()    { return _pos; }  
  MULTIARCH inline VectorType& normal() { return _normal; }
  };

private:
  VectorType _pos, _normal;
};
  \endcode


  The fitting kernel should also provide a macro, indicating the type of the fit. For example,
  \ref OrientedSphereFit defines
  \code
PROVIDES_ALGEBRAIC_SPHERE
  \endcode


  \subsection grenaille_howto_compat_sec Basket compatibility check

  The provided macros are checked by all the extensions to ensure the compatibility 
  during the compilation and throw human-readable error message. For example:
  \code
Patate/Grenaille/Core/gls.h:91:7: error: ‘PROVIDES_GLS_PARAMETRIZATION’ is not a member of ...
  \endcode
  indicates that the current configuration requires an extension defining the GLS 
  parametrization (in practice: \ref GLSParam).

  This error is thrown when trying to compile the type
\code
typedef Basket<MyPoint,WeightFunc,OrientedSphereFit, OrientedSphereScaleDer, GLSDer> Fit;
\endcode

  Please go the the documentation of the extensions you plan to use
  to know their requirements and the macros they provide.

  \subsection grenaille_howto_ext_sec Extensions
  Please follow the instructions defined in the documentation of the 
  Concept::FittingExtensionConcept.
  \warning Lot of materials are missing here !  

  \subsection grenaille_howto_weight_sec Weighting function

  There is two components combined to weight samples:
    - a 1D kernel, defined in the interval \f$ \left[0 \; : \; 1 \right]\f$,
  implementing the Concept::WeightKernelConcept. 
  Actually their is two kernels included in the library: 
  \ref ConstantWeightKernel and \ref SmoothWeightKernel. Please go to the 
  related documentation pages for more details.
    - a specialized function that will use this kernel with respect to a given
  point structure and implementing Concept::WeightFuncConcept. Only 
  \ref DistWeightFunc is provided yet, to compute a weight with respect to the
  distance between samples for a given scale \f$ t \f$ specified at runtime.

  An example of Weighting function with the MyPoint class:
  \code
typedef DistWeightFunc<MyPoint,SmoothWeightKernel<Scalar> > WeightFunc; 
  \endcode



 */
namespace Grenaille
{ 


  // create concept classes to document the Concept of a fitting approach and the
  // extensions
  /*!
    \brief Main concepts used in Grenaille
  */
  namespace Concept{
    /*!
      \brief Concept that have to be implemented by Fitting procedures.
      
      The typical usage of this approach is:
      \code    
        typedef Basket<MyPointStructure,MyWeightingFunction,MyFittingProcedure> Fit;
        MyWeightingFunction w ( some_parameters );

        // Create a fit object      
        Fit fit;
        
        // init the internal state with respect to the reference position
        fit.init( referencePosition );
        
        // set the weighting function. Has no influence of the other internals
        fit.setWeightFunc( w );
        
        foreach neighbors of referencePosition
          fit.addNeighbor(neighbor);
          
        fit.finalize();
        
        // use the fit
        // ... 
      \endcode
      
      \warning This class not really exist in the source code. It is only provided
      to describe the Concept that have to implement the fitting 
      procedures.    
     */
    template < class DataPoint, class _WFunctor, typename T = void >
    class FittingProcedureConcept {
      public:
      /**************************************************************************/
      /* Initialization                                                         */
      /**************************************************************************/
     /*! 
        \brief Init the WeightFunc, without changing the other internal states
        \warning Must be called be for any computation 
      */
      void setWeightFunc (const WFunctor& w){};
      
      /*!
        \brief Set the evaluation position and reset the internal states. 
        \warning Must be called be for any computation
      */
      void init (const VectorType& evalPos){};
      

      /**************************************************************************/
      /* Processing                                                             */
      /**************************************************************************/
      /*!
        \brief Add a neighbor to perform the fit 
      */
      void addNeighbor(const DataPoint &nei){};
      
      /*!
        \brief Finalize the fitting procedure    
        \warning Must be called be for any use of the fitting output
      */
      void finalize (){};    
    };
    
    /*!
      \brief Concept that have to be implemented by Fitting extensions.
      
      The typical usage of this approach is:
      \code
        typedef Basket<MyPointStructure,MyWeightingFunction,MyFittingProcedure, MyExtension1, MyExtension2, ...> ExtendedFit;
        MyWeightingFunction w ( some_parameters );

        // Create a fit object      
        ExtendedFit extFit;
        
        // init the internal state with respect to the reference position
        extFit.init( referencePosition );
        
        // set the weighting function. Has no influence of the other internals
        extFit.setWeightFunc( w );
        
        foreach neighbors of referencePosition
          extFit.addNeighbor(neighbor);
          
        extFit.finalize();
        
        // use the result of the fit and its extensions
        // ... 
      \endcode
      
      Any of the functions defined in an extension must first call the Base class:
      \code    
        MULTIARCH inline void init (const VectorType& evalPos){
          Base::init(evalPos);        
          //extended stuff
        };
      \endcode
      
      \warning This class not really exist in the source code. It is only provided
      to describe the Concept that have to implement the fitting 
      extensions.    
     */
    template < class DataPoint, class _WFunctor, typename T = void >
    class FittingExtensionConcept {
      public:
      /**************************************************************************/
      /* Initialization                                                         */
      /**************************************************************************/
      /*! \see FittingProcedureConcept::setWeightFunc */
      void setWeightFunc (const WFunctor& w){};
      
      /*! \see FittingProcedureConcept::init */
      void init (const VectorType& evalPos){};
      

      /**************************************************************************/
      /* Processing                                                             */
      /**************************************************************************/
      /*! \see FittingProcedureConcept::addNeighbor */
      void addNeighbor(const DataPoint &nei){};
      
      /*! \see FittingProcedureConcept::finalize */
      void finalize (){};    
    };
    
    
    /*!
      \brief This base class defines the weighting kernel concept
    */
    template <typename _Scalar>
    class WeightKernelConcept{
    public:
      typedef _Scalar Scalar;

      //! \brief Apply the weighting kernel to the scalar value \f$f(x)\f$
      MULTIARCH inline Scalar f  (const Scalar& x) const {}
      //! \brief Apply the first derivative of the weighting kernel to the scalar value \f$f'(x)\f$
      MULTIARCH inline Scalar df (const Scalar& x) const {}
      //! \brief Apply the second derivative of the weighting kernel to the scalar value \f$f''(x)\f$
      MULTIARCH inline Scalar ddf(const Scalar& x) const {}
    };// class WeightKernelConcept
    
    
    /*!
      \brief Weighting function concept
    */
    template <class DataPoint, typename Derived >
    class WeightFuncConcept {

    public:        
      typedef typename DataPoint::Scalar Scalar;
      typedef typename DataPoint::VectorType VectorType;
        
      /*! \brief Apply the weight function to a query. */
      MULTIARCH inline Scalar w(const VectorType& relativeQuery, 
			        const DataPoint&  attributes) const {}   
         
      /*! \brief Apply the weight function differenciated in space to a query. */
      MULTIARCH inline VectorType spacedw(const VectorType& relativeQuery, 
				      const DataPoint&  attributes) const {}   
         
      /*! \brief Apply the weight function differenciated in scale to a query. */
      MULTIARCH inline Scalar scaledw(const VectorType& relativeQuery, 
				      const DataPoint&  attributes) const {}

      /*! \brief Read access to the evaluation scale */
      MULTIARCH inline Scalar evalScale() const {}   
    };// class WeightFuncConcept
  
  } // End namespace Concept
} // End namespace Grenaille
