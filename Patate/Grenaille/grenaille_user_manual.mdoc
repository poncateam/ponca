namespace Grenaille
{
/*!
  \page grenaille_user_manual_page User Manual  
  
  Welcome to the Grenaille user manual. This page may either provide a detailed explanation of classes found in the module, or describe
  a simple example that makes use of basic functionalities. In the latter case, you will find a link to the complete example
  that implements this kind of tutorial.

  <h3>Table of Content</h3>
  - \ref grenaille_tutorial1_intro
    - \ref grenaille_tutorial1_section_define
      - \ref grenaille_tutorial1_subsection_define_samples
      - \ref grenaille_tutorial1_subsection_define_fit
    - \ref grenaille_tutorial1_section_fitting
    - \ref grenaille_tutorial1_section_access
      - \ref grenaille_tutorial1_section_access_field
      - \ref grenaille_tutorial1_section_access_sphere
      - \ref grenaille_tutorial1_section_access_other
  - \ref grenaille_tutorial2_intro
    - \ref grenaille_tutorial2_section_sphere
      - \ref grenaille_tutorial2_section_sphere_subsection_meancurvature
      - \ref grenaille_tutorial2_section_sphere_subsection_principalcurvatures


  \section grenaille_tutorial1_intro Grenaille basic use 
  
  This part explains the basics of the Grenaille module. The corresponding source-code is
  available at cpp/grenaille_basic_cpu.cpp.
 
  \section grenaille_tutorial1_section_define Setting up data and processes
  The first step needed to use Grenaille is to define how samples are represented isnide the module.
  A strength of Grenaille is to define all these structures at compile time to generate optimized code for fast evaluation at runtime. 

  \subsection grenaille_tutorial1_subsection_define_samples Samples
  The class Grenaille::Concept::PointConcept defines the interface that has to be implemented to represent a sample. Observe that there is no need for data conversion: all you need to do is to indicate how to access existing data.  
  
  As an example, let's fit a Grenaille::AlgebraicSphere onto points equipped with normals using the Grenaille::OrientedSphereFit. To this end, we must define a structure MyPoint containing a normal vector and its associated accessors. Because of the way Grenaille::AlgebraicSphere works, we must also define a Matrix Type.
  This leads to the following class:
  \code
  using namespace Grenaille;
  
  // This class defines the input data format
  class MyPoint{
  public:
    enum {Dim = 3};
    typedef double Scalar;
    typedef Eigen::Matrix<Scalar, Dim, 1>   VectorType;
    typedef Eigen::Matrix<Scalar, Dim, Dim> MatrixType; // Type needed by Grenaille::AlgebraicSphere

    MULTIARCH inline MyPoint(const VectorType &pos    = VectorType::Zero(), 
		   const VectorType& normal = VectorType::Zero())
      : _pos(pos), _normal(normal) {}
      
    MULTIARCH inline const VectorType& pos()    const { return _pos; }  
    MULTIARCH inline const VectorType& normal() const { return _normal; }

    MULTIARCH inline VectorType& pos()    { return _pos; }  
    MULTIARCH inline VectorType& normal() { return _normal; }

  private:
    VectorType _pos, _normal;
  };
  \endcode
  
  
  To make code more readable, we also define helper <CODE>typedef</CODE> for <CODE>Scalar</CODE> and 
  <CODE>Vector</CODE> types outside of the MyPoint class: 
  \code
  typedef MyPoint::Scalar Scalar;
  typedef MyPoint::VectorType VectorType;
  \endcode
  
  
  
  
  
  \subsection grenaille_tutorial1_subsection_define_fit Fitting
  Two template classes must be specialized to indicate how a fit must be applied.  
  
  The first step consists in identifying a weighting function: it defines how neighbor samples will contribute to the fit. In this example, we choose a weight based on the Euclidean distance using Grenaille::DistWeightFunc, remaped through a bisquare kernel defined in Grenaille::SmoothWeightKernel:
  \code
  typedef DistWeightFunc<MyPoint,SmoothWeightKernel<Scalar> > WeightFunc; 
  \endcode
  
  The second step identifies a complete fitting procedure through the specialization of a Grenaille::Basket. In our example, we want to apply an Grenaille::OrientedSphereFit to input data points, which outputs an Grenaille::AlgebraicSphere by default. We further require such a sphere to be reparametrized using a Grenaille::GLSParam extension, which provides more intuitive parameters. This leads to the following specialization:
  
  \code
  typedef Basket<MyPoint,WeightFunc,OrientedSphereFit, GLSParam> Fit1;  
  \endcode
  
  
    
  
  \section grenaille_tutorial1_section_fitting Applying the fitting procedure

  At this point, most of the hard job has already been performed. 
  All we have to do now is to provide an instance of the weight function, where tmax refers to the neighborhood size, and iniate the fit at an arbitrary position p.
  \code
  // Create the previously defined fitting procedure
  Fit1 fit;
  
  // Set a weighting function instance
  fit.setWeightFunc(WeightFunc(tmax));
  
  // Set the evaluation position
  fit.init(p);
  \endcode
  
  Then neighbors are added sequentially: in this example, we traverse a simple array, and samples outside of the neighborhood are automatically ignored by the weighting function.
  Once all neighbors have been incorporated, the call to the finalize function actually performs the fit and stores results in the specialized Basket object.
  
  \code
  // Iterate over samples and fit the primitive
  for(vector<MyPoint>::iterator it = vecs.begin(); it != vecs.end(); it++)
    fit.addNeighbor(*it); 
    
  //finalize fitting 
  fit.finalize();
  \endcode
  
  
  
  \section grenaille_tutorial1_section_access Playing with output values
  Various outputs may now be accessed as explained in the following.
  
  \subsection grenaille_tutorial1_section_access_field Scalar field  
  You may directly access properties of the fitted scalar-field, as defined in Grenaille::AlgebraicSphere :
  \code
  cout << "Value of the scalar field at the initial point: " 
       << p.transpose() 
       << " is equal to " << fit.potential(p)
       << endl;
       
  cout << "Its gradient is equal to: "
       << fit.primitiveGradient(p).transpose()
       << endl;
  \endcode  
  This generates the following output:
  \code
  Value of the scalar field at the initial point: 0 0 0 is equal to -0.501162
  Its gradient is equal to:   0.00016028  0.000178782 -0.000384989
  \endcode
  
  \subsection grenaille_tutorial1_section_access_sphere Sphere
  You may rather access properties of the fitted sphere (the 0-isosurface of the fitted scalar field), as defined in Grenaille::AlgebraicSphere :
  \code
  cout << "Center: [" << fit.center().transpose() << "] ;  radius: " << fit.radius() << endl;
  \endcode
  You will obtain:
  \code 
  Center: [-0.000160652 -0.000179197  0.000385884] ;  radius: 1.00232
  \endcode
  
  Alternatively, you may prefer accessing parameters provided by the Grenaille::GLSParam extension:
  \code
  cout << "Fitted Sphere: " << endl
       << "\t Tau  : "      << fit.tau()             << endl
       << "\t Eta  : "      << fit.eta().transpose() << endl
       << "\t Kappa: "      << fit.kappa()           << endl;
  \endcode
  You will obtain:
  \code 
	Fitted Sphere: 
	  Tau  : -0.501162
	  Eta  :   0.35325  0.394028 -0.848502
	  Kappa: 0.997682 
  \endcode
    
  \subsection grenaille_tutorial1_section_access_other Other methods
  Thanks to the Grenaille::AlgebraicSphere, you may also project an arbitrary point onto the fitted sphere via:
  \code
  cout << "The initial point " << p.transpose()              << endl
       << "Is projected at   " << fit.project(p).transpose() << endl;
  \endcode
  You will then obtain:
  \code
  The initial point 0 0 0
  Is projected at    0.353911  0.394765 -0.850088
  \endcode



  \section grenaille_tutorial2_intro Grenaille curvature use
  
  This part presents how to compute curvature values from the various fitting
  procedures and extensions available in Grenaille.
  
  \section grenaille_tutorial2_section_sphere Curvature using sphere fitting
  \subsection grenaille_tutorial2_section_sphere_subsection_meancurvature Mean Curvature
  A fast approximation of the mean curvature is provided by GLSParam::kappa():
  \code
  typedef Basket<MyPoint, WeightFunc, OrientedSphereFit, // Sphere fitting
                                      GLSParam> Fit;     // GLS reparametrization
  
  Fit fit;
  // Fit primitive
  // ... 
  
  // Get mean curvature
  Scalar curvature = fit.kappa();
  \endcode
  
  It can also be extracted by analysing the spatial derivatives of fitted normals, 
  provided by GLSDer::deta(). Note that the computation cost is more important 
  in this case.
  \code
  typedef Basket<MyPoint, WeightFunc, OrientedSphereFit,    // Sphere fitting
                                    GLSParam,               // GLS reparametrization
                                    OrientedSphereSpaceDer, // Spatial derivatives 
                                    GLSDer > Fit;           // GLS differentiation                                    
  
  Fit fit;
  // Fit primitive
  // ... 
  
  // Mean curvature values is given by half of the trace of the jacobian matrix
  MatrixType jacobian = fit.deta();  
  cout << " Mean curvature: " << 0.5 * jacobian.trace() << endl;
  \endcode
    
  \subsection grenaille_tutorial2_section_sphere_subsection_principalcurvatures Principal Curvatures
  Principal curvature values and the associated directions can be computed by 
  an eigen decomposition of the spatial derivatives of eta, provided by 
  the extension GLSCurvatureHelper (based on the analysis of GLSDer::deta()):
  \code
  typedef Basket<MyPoint, WeightFunc, OrientedSphereFit,    // Sphere fitting
                                    GLSParam,               // GLS reparametrization
                                    OrientedSphereSpaceDer, // Spatial derivatives 
                                    GLSDer,                 // GLS differentiation   
                                    GLSCurvatureHelper > Fit;           
  
  Fit fit;
  // Fit primitive
  // ... 
  // The eigen decomposition is called during the fit finalize
  fit.finalize();
  
  // Get principal curvatures
  Scalar k1 = fit.GLSk1();
  Scalar k2 = fit.GLSk2();
  
  // Get associated directions
  VectorType d1 = fit.GLSk1Direction();
  VectorType d2 = fit.GLSk2Direction();
  
  // Get gaussian curvature
  Scalar K = fit.GLSGaussianCurvature();
  \endcode
 */
 }