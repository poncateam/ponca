<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ponca: Fitting module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ponca.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ponca
   &#160;<span id="projectnumber">49cec0828ff3928bf81c3c0981b0888e9775064e</span>
   </div>
   <div id="projectbrief">Point Cloud Analysis library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Fitting module</div>  </div>
</div><!--header-->
<div class="contents">

<p>This modules includes classes and methods for primitive fitting. See reference manual below.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Fitting module:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__fitting.svg" width="330" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__fittingExperimental"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fittingExperimental.html">Fitting-Experimental features</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1AlgebraicSphere.html">Ponca::AlgebraicSphere&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraic Sphere primitive.  <a href="classPonca_1_1AlgebraicSphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1Basket.html">Ponca::Basket&lt; P, W, Fit, Ext0, Ext1, Ext2, Ext3, Ext4, Ext5, Ext6, Ext7, Ext8, Ext9, Ext10, Ext11 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Agregator class used to declare specialized structures using CRTP (Curiously Recurring Template Pattern)  <a href="classPonca_1_1Basket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1CovariancePlaneFit.html">Ponca::CovariancePlaneFit&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plane fitting procedure using only points position.  <a href="classPonca_1_1CovariancePlaneFit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1internal_1_1CovariancePlaneDer.html">Ponca::internal::CovariancePlaneDer&lt; DataPoint, _WFunctor, T, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal generic class computing the derivatives of covariance plane fits.  <a href="classPonca_1_1internal_1_1CovariancePlaneDer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1CovariancePlaneScaleDer.html">Ponca::CovariancePlaneScaleDer&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Differentiation in scale of the <a class="el" href="classPonca_1_1CovariancePlaneFit.html" title="Plane fitting procedure using only points position.">CovariancePlaneFit</a>.  <a href="classPonca_1_1CovariancePlaneScaleDer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1CovariancePlaneSpaceDer.html">Ponca::CovariancePlaneSpaceDer&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial differentiation of the <a class="el" href="classPonca_1_1CovariancePlaneFit.html" title="Plane fitting procedure using only points position.">CovariancePlaneFit</a>.  <a href="classPonca_1_1CovariancePlaneSpaceDer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1CovariancePlaneScaleSpaceDer.html">Ponca::CovariancePlaneScaleSpaceDer&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Differentiation both in scale and space of the <a class="el" href="classPonca_1_1CovariancePlaneFit.html" title="Plane fitting procedure using only points position.">CovariancePlaneFit</a>.  <a href="classPonca_1_1CovariancePlaneScaleSpaceDer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1GLSParam.html">Ponca::GLSParam&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Growing Least Squares reparemetrization of the <a class="el" href="classPonca_1_1OrientedSphereFit.html" title="Algebraic Sphere fitting procedure on oriented point sets.">OrientedSphereFit</a>.  <a href="classPonca_1_1GLSParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1GLSDer.html">Ponca::GLSDer&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Differentiation of <a class="el" href="classPonca_1_1GLSParam.html" title="Growing Least Squares reparemetrization of the OrientedSphereFit.">GLSParam</a>.  <a href="classPonca_1_1GLSDer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1GLSGeomVar.html">Ponca::GLSGeomVar&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension to compute the Geometric Variation of <a class="el" href="classPonca_1_1GLSParam.html" title="Growing Least Squares reparemetrization of the OrientedSphereFit.">GLSParam</a>.  <a href="classPonca_1_1GLSGeomVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1GLSCurvatureHelper.html">Ponca::GLSCurvatureHelper&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1LeastSquareLine.html">Ponca::LeastSquareLine&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPonca_1_1Line.html" title="A parametrized line is defined by an origin point  and a unit direction vector  such that the line co...">Line</a> fitting procedure that minimize the orthogonal distance between the samples and the fitted primitive.  <a href="classPonca_1_1LeastSquareLine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1Line.html">Ponca::Line&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parametrized line is defined by an origin point \(\mathbf{o}\) and a unit direction vector \(\overrightarrow{\mathbf{d}}\) such that the line corresponds to the set \(l(t)=\mathbf{o}+t\overrightarrow{\mathbf{d}}, t\in \mathbb{R}\).  <a href="classPonca_1_1Line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1MeanPlaneFit.html">Ponca::MeanPlaneFit&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plane fitting procedure computing the mean position and orientation from oriented points.  <a href="classPonca_1_1MeanPlaneFit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1MlsSphereFitDer.html">Ponca::MlsSphereFitDer&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension performing derivation of the mls surface.  <a href="classPonca_1_1MlsSphereFitDer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1MongePatch.html">Ponca::MongePatch&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension to compute the best fit quadric on 3d points expressed as f(u,v)=h.  <a href="classPonca_1_1MongePatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1OrientedSphereFit.html">Ponca::OrientedSphereFit&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraic Sphere fitting procedure on oriented point sets.  <a href="classPonca_1_1OrientedSphereFit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1CompactPlane.html">Ponca::CompactPlane&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit hyperplane defined by an homogeneous vector \(\mathbf{p}\).  <a href="classPonca_1_1CompactPlane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1PrimitiveBase.html">Ponca::PrimitiveBase&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive base class.  <a href="classPonca_1_1PrimitiveBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1SphereFit.html">Ponca::SphereFit&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraic Sphere fitting procedure on point sets without normals.  <a href="classPonca_1_1SphereFit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1UnorientedSphereFit.html">Ponca::UnorientedSphereFit&lt; DataPoint, _WFunctor, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraic Sphere fitting procedure on point sets with non-oriented normals.  <a href="classPonca_1_1UnorientedSphereFit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1DistWeightFunc.html">Ponca::DistWeightFunc&lt; DataPoint, WeightKernel &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighting function based on the euclidean distance between a query and a reference position.  <a href="classPonca_1_1DistWeightFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPonca_1_1ConstantWeightKernel.html">Ponca::ConstantWeightKernel&lt; _Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPonca_1_1Concept_1_1WeightKernelConcept.html" title="A 1D weighting function and its derivatives.">Concept::WeightKernelConcept</a> returning a constant value.  <a href="classPonca_1_1ConstantWeightKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabfd697aebf07c1b5c8be5ee401e2dc84"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fitting.html#gabfd697aebf07c1b5c8be5ee401e2dc84">Ponca::FIT_RESULT</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="group__fitting.html#ggabfd697aebf07c1b5c8be5ee401e2dc84a86d1e5381a39092fbe5560583c23d64c">Ponca::STABLE</a> = 0, 
<a class="el" href="group__fitting.html#ggabfd697aebf07c1b5c8be5ee401e2dc84ab13222e506596eb607093af1a1de3e39">Ponca::UNSTABLE</a> = 1, 
<a class="el" href="group__fitting.html#ggabfd697aebf07c1b5c8be5ee401e2dc84a08d57dd200082f67128b5274049dda41">Ponca::UNDEFINED</a> = 2, 
<a class="el" href="group__fitting.html#ggabfd697aebf07c1b5c8be5ee401e2dc84a0d50cd1855fec459b2c5756ec38d4a17">Ponca::NEED_OTHER_PASS</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__fitting.html#ggabfd697aebf07c1b5c8be5ee401e2dc84a405923cb4af5edb343e87ec895c01c2c">Ponca::NBMAX</a>
<br />
 }</td></tr>
<tr class="separator:gabfd697aebf07c1b5c8be5ee401e2dc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This modules includes classes and methods for primitive fitting. See reference manual below. </p>
<h1><a class="anchor" id="fitting_intro"></a>
Introduction</h1>
<p>The fitting module is dedicated to the smooth fitting of point clouds and extraction of useful geometric properties. Figure 1(a) shows a typical example in 2D: we reconstruct a potential function (shown in fake colors) from a few 2D points equipped with normals; then the 0-isoline of this potential gives us an implicit curve (in orange) from which we can readily extract further properties like curvature. A great benefit of this implicit technique <a class="el" href="citelist.html#CITEREF_Guennebaud:2007:APSS">[3]</a> is that it works in arbitrary dimensions: Figures 1(b-c) show how we reconstruct an implicit 3D surface with the same approach, starting from a 3D point cloud. Working with meshes then simply consists of only considering their vertices.</p>
<p>This is just the tip of the iceberg though, as we also provide methods for dealing with points equipped with non-oriented normals <a class="el" href="citelist.html#CITEREF_Chen:2013:NOMG">[2]</a>, techniques to analyze points clouds in scale-space to discover salient structures <a class="el" href="citelist.html#CITEREF_Mellado:2012:GLS">[5]</a>, methods to compute multi-scale principal curvatures <a class="el" href="citelist.html#CITEREF_Mellado:2013:SSC">[6]</a> and methods to compute surface variation using a plane instead of a sphere for the fitting <a class="el" href="citelist.html#CITEREF_Pauly:2002:PSSimplification">[7]</a>. See the table below:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Primitive </th><th class="markdownTableHeadNone">Required Input </th><th class="markdownTableHeadNone">Fitting techniques </th><th class="markdownTableHeadNone">Analysis/Tools </th><th class="markdownTableHeadNone">Other usages  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Plane </td><td class="markdownTableBodyNone">Points only </td><td class="markdownTableBodyNone"><a class="el" href="classPonca_1_1CovariancePlaneFit.html" title="Plane fitting procedure using only points position.">CovariancePlaneFit</a> (nD) </td><td class="markdownTableBodyNone">Surface Variation (nD)<a class="el" href="citelist.html#CITEREF_Pauly:2002:PSSimplification">[7]</a> </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Plane </td><td class="markdownTableBodyNone">Oriented points </td><td class="markdownTableBodyNone"><a class="el" href="classPonca_1_1MeanPlaneFit.html" title="Plane fitting procedure computing the mean position and orientation from oriented points.">MeanPlaneFit</a> (nD, co-dimension 1) </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Monge Patch </td><td class="markdownTableBodyNone">Points only </td><td class="markdownTableBodyNone"><a class="el" href="classPonca_1_1MongePatch.html" title="Extension to compute the best fit quadric on 3d points expressed as f(u,v)=h.">MongePatch</a> (3D) </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Algebraic Sphere </td><td class="markdownTableBodyNone">Oriented points </td><td class="markdownTableBodyNone"><a class="el" href="classPonca_1_1OrientedSphereFit.html" title="Algebraic Sphere fitting procedure on oriented point sets.">OrientedSphereFit</a> (nD) <a class="el" href="citelist.html#CITEREF_Guennebaud:2007:APSS">[3]</a> </td><td class="markdownTableBodyNone">GLS (nD) <a class="el" href="citelist.html#CITEREF_Mellado:2012:GLS">[5]</a> </td><td class="markdownTableBodyNone">Ray Traced Curvature <a class="el" href="citelist.html#CITEREF_Mellado:2013:SSC">[6]</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Algebraic Sphere </td><td class="markdownTableBodyNone">Non-oriented points </td><td class="markdownTableBodyNone"><a class="el" href="classPonca_1_1UnorientedSphereFit.html" title="Algebraic Sphere fitting procedure on point sets with non-oriented normals.">UnorientedSphereFit</a> (nD) <a class="el" href="citelist.html#CITEREF_Chen:2013:NOMG">[2]</a> </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classPonca_1_1Line.html" title="A parametrized line is defined by an origin point  and a unit direction vector  such that the line co...">Line</a> </td><td class="markdownTableBodyNone">Points only </td><td class="markdownTableBodyNone"><a class="el" href="classPonca_1_1LeastSquareLine.html" title="Line fitting procedure that minimize the orthogonal distance between the samples and the fitted primi...">LeastSquareLine</a> (3D) </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>In the following, we focus on a basic use of the module, using 3D points equipped with oriented normals fitted by a <a class="el" href="classPonca_1_1AlgebraicSphere.html" title="Algebraic Sphere primitive.">Ponca::AlgebraicSphere</a>. First, one must set up data samples that interface with an external code; then run the fitting process in itself, and finally collect outputs. We also show how to compute curvatures with the very same approach, as this is a common requirement of many geometric processing algorithms.</p>
<div class="image">
<img src="interpolation.png" alt=""/>
<div class="caption">
Figure 1: (a) An implicit 2D curve fit to a 2D point cloud. (b) A 3D point cloud shown with splats. (c) An implicit 3D surface reconstructed from (b).</div></div>
<h2><a class="anchor" id="fitting_codeStructure"></a>
Code structure</h2>
<p>We structured <a class="el" href="namespacePonca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a> as follow: a <code>Fitting</code> folder defining operators that rely on no data structure and work both with CUDA and C++; and an <code>Algorithm</code> folder with methods that may interface with user-provided data structures, with optimized solutions in C++, CUDA or both. The rationale behind this separation is to provide two levels of complexity: core operators implement atomic scientific contributions that are agnostic of the host application; algorithms implement step-by-step procedures that will likely rely on core operators and/or structure traversal.</p>
<p>In its current state, we do not have algorithms for <a class="el" href="namespacePonca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a> implemented: it's work in progress (we are open to contributions). If you want to use <a class="el" href="namespacePonca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a>, just include its main header: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Ponca/Ponca&quot;</span></div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Ponca/Fitting&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="fitting_cuda"></a>
Cuda</h2>
<p><a class="el" href="namespacePonca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a> can be used directly on GPU, thanks to several mechanisms:</p><ul>
<li>Eigen Cuda capabilities, see <a href="http://eigen.tuxfamily.org/dox-devel/TopicCUDA.html" target="_blank">Eigen documentation</a> for more details. You <em>need</em> to use a consistent Eigen::Index on both CPU and GPU if you plan to transfer memory between the computing units. That's why we recommend to set the following preprocessor variable when compiling your project: <div class="fragment"><div class="line">-DEIGEN_DEFAULT_DENSE_INDEX_TYPE=<span class="keywordtype">int</span></div>
</div><!-- fragment --> You might also need to define the <code>--expt-relaxed-constexpr</code> preprocessor option for <code>NVCC</code>. Example of working cmake file (see <a class="el" href="example_cu_ssc_page.html">Screen Space Curvature using Cuda/C++</a>): <div class="fragment"><div class="line">enable_language(CUDA)</div>
<div class="line">add_executable(ponca_ssgls <span class="stringliteral">&quot;ponca_ssgls.cu&quot;</span>)</div>
<div class="line">target_compile_options(ponca_ssgls PRIVATE --expt-relaxed-constexpr)</div>
</div><!-- fragment --></li>
<li>C++03 Compliant: right now we <em>do not</em> use C++11 in <a class="el" href="namespacePonca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a> when compiled with CUDA, to maximize compatibility across platforms and Cuda versions.</li>
<li>Automatic CPU/GPU compilation qualifiers. We use the macro <div class="fragment"><div class="line">PONCA_MULTIARCH <span class="keywordtype">void</span> <span class="keyword">function</span>();</div>
</div><!-- fragment --> to use the same code for C++ and CUDA. It has no effect when the code is compiled with GCC or Clang, but it will force the compilation for both host and device architectures when compiling with nvcc. A similar macro system is provided for mathematical functions, to switch between STL and CUDA versions.</li>
</ul>
<p>Check the C++/Cuda and <a class="el" href="example_python_ssc_page.html">Python/Cuda</a> (using PyCuda) examples for more details and how-to.</p>
<p>You are now ready to read the next sections, and discover how to interface <a class="el" href="namespacePonca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a> with your data-structures, how to fit various primitives and compute geometrical and differential properties.</p>
<h1><a class="anchor" id="fitting_datas"></a>
Data Samples</h1>
<p>The first step needed to use <a class="el" href="namespacePonca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a> is to define how samples are represented inside the module. A strength of <a class="el" href="namespacePonca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a> is to define all these structures at compile time to generate optimized code for fast evaluation at runtime.</p>
<p>The class <a class="el" href="classPonca_1_1Concept_1_1PointConcept.html" title="Definition of a point sample.">Ponca::Concept::PointConcept</a> defines the interface that has to be implemented to represent a sample. Observe that there is no need for data conversion: all you need to do is to indicate how to access existing data.</p>
<dl class="section warning"><dt>Warning</dt><dd>You should avoid data of low magnitude (i.e., 1 should be a significant value) to get good results; thus rescaling might be necessary.</dd></dl>
<p>As an example, let's fit a <a class="el" href="classPonca_1_1AlgebraicSphere.html" title="Algebraic Sphere primitive.">Ponca::AlgebraicSphere</a> onto points equipped with normals using the <a class="el" href="classPonca_1_1OrientedSphereFit.html" title="Algebraic Sphere fitting procedure on oriented point sets.">Ponca::OrientedSphereFit</a>. To this end, we must define a structure <code>MyPoint</code> containing a normal vector and its associated accessors. Depending on the fitting procedure we will use, we may need to define a Matrix Type. This is for instance required to compute <a class="el" href="group__fitting.html#fitting_subsection_principalcurvatures">Principal Curvatures</a>. This leads to the following class: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacePonca.html">Ponca</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This class defines the input data format</span></div>
<div class="line"><span class="keyword">class </span>MyPoint</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">enum</span> {Dim = 3};</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span> Scalar;</div>
<div class="line">  <span class="keyword">typedef</span> Eigen::Matrix&lt;Scalar, Dim, 1&gt;   VectorType;</div>
<div class="line">  <span class="keyword">typedef</span> Eigen::Matrix&lt;Scalar, Dim, Dim&gt; MatrixType; <span class="comment">// Type needed by Ponca::GLSCurvatureHelper</span></div>
<div class="line"> </div>
<div class="line">  PONCA_MULTIARCH <span class="keyword">inline</span> MyPoint(<span class="keyword">const</span> VectorType &amp;pos    = VectorType::Zero(),</div>
<div class="line">                 <span class="keyword">const</span> VectorType&amp; normal = VectorType::Zero())</div>
<div class="line">    : _pos(pos), _normal(normal) {}</div>
<div class="line"> </div>
<div class="line">  PONCA_MULTIARCH <span class="keyword">inline</span> <span class="keyword">const</span> VectorType&amp; pos()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> _pos; }</div>
<div class="line">  PONCA_MULTIARCH <span class="keyword">inline</span> <span class="keyword">const</span> VectorType&amp; normal()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _normal; }</div>
<div class="line"> </div>
<div class="line">  PONCA_MULTIARCH <span class="keyword">inline</span> VectorType&amp; pos()    { <span class="keywordflow">return</span> _pos; }</div>
<div class="line">  PONCA_MULTIARCH <span class="keyword">inline</span> VectorType&amp; normal() { <span class="keywordflow">return</span> _normal; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  VectorType _pos, _normal;</div>
<div class="line">};</div>
</div><!-- fragment --><p>To make the code more readable, we also define <code>typedef</code> helpers for <code>Scalar</code> and <code>Vector</code> types outside of the MyPoint class: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> MyPoint::Scalar Scalar;</div>
<div class="line"><span class="keyword">typedef</span> MyPoint::VectorType VectorType;</div>
</div><!-- fragment --><h1><a class="anchor" id="fitting_Fitting"></a>
Fitting Process</h1>
<p>Two template classes must be specialized to indicate how a fit will be applied.</p>
<p>The first step consists in identifying a weighting function: it defines how neighbor samples will contribute to the fit, as illustrated in Figure 2(a) in 2D. In this example, we choose a weight based on the Euclidean distance using <a class="el" href="classPonca_1_1DistWeightFunc.html" title="Weighting function based on the euclidean distance between a query and a reference position.">Ponca::DistWeightFunc</a>, remapped through a bisquare kernel defined in <a class="el" href="classPonca_1_1SmoothWeightKernel.html" title="Smooth WeightKernel defined in .">Ponca::SmoothWeightKernel</a>: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> DistWeightFunc&lt;MyPoint,SmoothWeightKernel&lt;Scalar&gt; &gt; WeightFunc;</div>
</div><!-- fragment --><p>The second step identifies a complete fitting procedure through the specialization of a <a class="el" href="classPonca_1_1Basket.html" title="Agregator class used to declare specialized structures using CRTP (Curiously Recurring Template Patte...">Ponca::Basket</a>. In our example, we want to apply an <a class="el" href="classPonca_1_1OrientedSphereFit.html" title="Algebraic Sphere fitting procedure on oriented point sets.">Ponca::OrientedSphereFit</a> to input data points, which outputs an <a class="el" href="classPonca_1_1AlgebraicSphere.html" title="Algebraic Sphere primitive.">Ponca::AlgebraicSphere</a> by default. We further require such a sphere to be reparametrized using a <a class="el" href="classPonca_1_1GLSParam.html" title="Growing Least Squares reparemetrization of the OrientedSphereFit.">Ponca::GLSParam</a> extension, which provides more intuitive parameters. This leads to the following specialization:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Basket&lt;MyPoint,WeightFunc,OrientedSphereFit, GLSParam&gt; Fit1;</div>
</div><!-- fragment --><p>At this point, most of the hard job has already been performed. All we have to do now is to provide an instance of the weight function, where t refers to the neighborhood size, and iniate the fit at an arbitrary position p. </p><div class="fragment"><div class="line"><span class="comment">// Create the previously defined fitting procedure</span></div>
<div class="line">Fit1 fit;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a weighting function instance</span></div>
<div class="line">fit.setWeightFunc(WeightFunc(t));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the evaluation position</span></div>
<div class="line">fit.init(p);</div>
</div><!-- fragment --><p>Then neighbors are added sequentially: in this example, we traverse a simple array, and samples outside of the neighborhood are automatically ignored by the weighting function. Once all neighbors have been incorporated, the fit is performed and results stored in the specialized <a class="el" href="classPonca_1_1Basket.html" title="Agregator class used to declare specialized structures using CRTP (Curiously Recurring Template Patte...">Basket</a> object. STL-like iterators can be used directly for the fit by calling </p><div class="fragment"><div class="line">fit.compute(vecs.begin(), vecs.end());</div>
</div><!-- fragment --><p>Internally, the container is traversed and the method <code>finalize</code> is called at the end: </p><div class="fragment"><div class="line"><span class="comment">// Iterate over samples and fit the primitive</span></div>
<div class="line"><span class="keywordflow">for</span>(vector&lt;MyPoint&gt;::iterator it = vecs.begin(); it != vecs.end(); it++)</div>
<div class="line">  fit.addNeighbor(*it);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//finalize fitting</span></div>
<div class="line">fit.finalize();</div>
</div><!-- fragment --><p>After calling <code>finalize</code> or <code>compute</code>, it is better to test the return state of the fitting before using it. There are diffent states but the most important one is <code>STABLE</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="group__fitting.html#gabfd697aebf07c1b5c8be5ee401e2dc84">FIT_RESULT</a> eResult = fit.compute(vecs.begin(), vecs.end()); <span class="comment">// or = fit.finalize();</span></div>
<div class="line"><span class="keywordflow">if</span>(eResult == <a class="code" href="group__fitting.html#ggabfd697aebf07c1b5c8be5ee401e2dc84a86d1e5381a39092fbe5560583c23d64c">STABLE</a>)</div>
<div class="line">{</div>
<div class="line">      <span class="comment">//do things...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>You may also use accessors to perform the same check:</p>
<div class="fragment"><div class="line">fit.compute(vecs.begin(), vecs.end());</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(fit.isStable()) <span class="comment">//You can also check the function isReady()</span></div>
<div class="line">{</div>
<div class="line">      <span class="comment">//do things;</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="gls.png" alt=""/>
<div class="caption">
Figure 2. (a) Fitting a 2D point cloud of positions and normals at a point p (in red) requires to define a weight function of size t (in green). (b) This results in an implicit scalar field (in fake colors), from which parameters of a local spherical surface can be extracted: an offset tau, a normal eta and a curvature kappa.</div></div>
<h1><a class="anchor" id="fitting_outputs"></a>
Basic Outputs</h1>
<p>Now that you have performed fitting, you may use its outputs in a number of ways (see Figure 2(b) for an illustration in 2D).</p>
<h2><a class="anchor" id="fitting_subsection_access_field"></a>
Scalar field</h2>
<p>You may directly access properties of the fitted scalar-field, as defined in <a class="el" href="classPonca_1_1AlgebraicSphere.html" title="Algebraic Sphere primitive.">Ponca::AlgebraicSphere</a> : </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Value of the scalar field at the initial point: &quot;</span></div>
<div class="line">     &lt;&lt; p.transpose()</div>
<div class="line">     &lt;&lt; <span class="stringliteral">&quot; is equal to &quot;</span> &lt;&lt; fit.potential(p)</div>
<div class="line">     &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Its gradient is equal to: &quot;</span></div>
<div class="line">     &lt;&lt; fit.primitiveGradient(p).transpose()</div>
<div class="line">     &lt;&lt; endl;</div>
</div><!-- fragment --><p> This generates the following output: </p><div class="fragment"><div class="line">Value of the scalar field at the initial point: 0 0 0 is equal to -0.501162</div>
<div class="line">Its gradient is equal to:   0.00016028  0.000178782 -0.000384989</div>
</div><!-- fragment --><h2><a class="anchor" id="fitting_subsection_access_sphere"></a>
Sphere</h2>
<p>You may rather access properties of the fitted sphere (the 0-isosurface of the fitted scalar field), as defined in <a class="el" href="classPonca_1_1AlgebraicSphere.html" title="Algebraic Sphere primitive.">Ponca::AlgebraicSphere</a> : </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Center: [&quot;</span> &lt;&lt; fit.center().transpose() &lt;&lt; <span class="stringliteral">&quot;] ;  radius: &quot;</span> &lt;&lt; fit.radius() &lt;&lt; endl;</div>
</div><!-- fragment --><p> You will obtain: </p><div class="fragment"><div class="line">Center: [-0.000160652 -0.000179197  0.000385884] ;  radius: 1.00232</div>
</div><!-- fragment --><p>Alternatively, you may prefer accessing parameters provided by the <a class="el" href="classPonca_1_1GLSParam.html" title="Growing Least Squares reparemetrization of the OrientedSphereFit.">Ponca::GLSParam</a> extension: </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Fitted Sphere: &quot;</span> &lt;&lt; endl</div>
<div class="line">     &lt;&lt; <span class="stringliteral">&quot;\t Tau  : &quot;</span>      &lt;&lt; fit.tau()             &lt;&lt; endl</div>
<div class="line">     &lt;&lt; <span class="stringliteral">&quot;\t Eta  : &quot;</span>      &lt;&lt; fit.eta().transpose() &lt;&lt; endl</div>
<div class="line">     &lt;&lt; <span class="stringliteral">&quot;\t Kappa: &quot;</span>      &lt;&lt; fit.kappa()           &lt;&lt; endl;</div>
</div><!-- fragment --><p> You will obtain: </p><div class="fragment"><div class="line">Fitted Sphere:</div>
<div class="line">  Tau  : -0.501162</div>
<div class="line">  Eta  :   0.35325  0.394028 -0.848502</div>
<div class="line">  Kappa: 0.997682</div>
</div><!-- fragment --><h2><a class="anchor" id="fitting_subsection_access_other"></a>
Other methods</h2>
<p>Thanks to the <a class="el" href="classPonca_1_1AlgebraicSphere.html" title="Algebraic Sphere primitive.">Ponca::AlgebraicSphere</a>, you may also project an arbitrary point onto the fitted sphere via: </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;The initial point &quot;</span> &lt;&lt; p.transpose()              &lt;&lt; endl</div>
<div class="line">     &lt;&lt; <span class="stringliteral">&quot;Is projected at   &quot;</span> &lt;&lt; fit.project(p).transpose() &lt;&lt; endl;</div>
</div><!-- fragment --><p> You will then obtain: </p><div class="fragment"><div class="line">The initial point 0 0 0</div>
<div class="line">Is projected at    0.353911  0.394765 -0.850088</div>
</div><!-- fragment --><h1><a class="anchor" id="fitting_cuvature"></a>
Computing Curvatures</h1>
<p>This part presents how to compute curvature values from the various fitting procedures and extensions available in <a class="el" href="namespacePonca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a>.</p>
<h2><a class="anchor" id="fitting_subsection_meancurvature"></a>
Mean Curvature</h2>
<p>A fast approximation of the mean curvature is provided by <a class="el" href="classPonca_1_1GLSParam.html#af50e8af7862b3dcb185ff21c573fa784" title="Compute and return .">GLSParam::kappa()</a> and illustrated at two scales on a 3D surface in Figure 3: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> Basket&lt;MyPoint, WeightFunc, OrientedSphereFit, <span class="comment">// Sphere fitting</span></div>
<div class="line">                                    GLSParam&gt; Fit;     <span class="comment">// GLS reparametrization</span></div>
<div class="line"> </div>
<div class="line">Fit fit;</div>
<div class="line"><span class="comment">// Fit primitive</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get mean curvature</span></div>
<div class="line">Scalar curvature = fit.kappa();</div>
</div><!-- fragment --><p>It can also be extracted by analysing the spatial derivatives of fitted normals, provided by <a class="el" href="classPonca_1_1GLSDer.html#a0ae73609529b5939e87dabcd94c15e77" title="Compute and return  derivatives.">GLSDer::deta()</a>. Note that the computational cost is more important in this case. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> Basket&lt;MyPoint, WeightFunc, OrientedSphereFit,    <span class="comment">// Sphere fitting</span></div>
<div class="line">                                  GLSParam,               <span class="comment">// GLS reparametrization</span></div>
<div class="line">                                  OrientedSphereSpaceDer, <span class="comment">// Spatial derivatives</span></div>
<div class="line">                                  GLSDer &gt; Fit;           <span class="comment">// GLS differentiation</span></div>
<div class="line"> </div>
<div class="line">Fit fit;</div>
<div class="line"><span class="comment">// Fit primitive</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Mean curvature values is given by half of the trace of the jacobian matrix</span></div>
<div class="line">MatrixType jacobian = fit.deta();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot; Mean curvature: &quot;</span> &lt;&lt; 0.5 * jacobian.trace() &lt;&lt; endl;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In this example, we build the Jacobian from <code>fit.deta()</code>, using an implicit cast from <code>VectorArray</code> to <code>MatrixType</code>. It will require a more careful conversion when the basket contains different extensions. More details <a class="el" href="classPonca_1_1internal_1_1OrientedSphereDer.html">here.</a></dd></dl>
<div class="image">
<img src="buste.png" alt=""/>
<div class="caption">
Figure 3. Mean curvature computed at a fine (left) and a coarse (right) scale, and rendered with a simple color map (orange for concavities, blue for convexities).</div></div>
<h2><a class="anchor" id="fitting_subsection_principalcurvatures"></a>
Principal Curvatures</h2>
<p>Principal curvatures and their associated directions can be computed by an eigen decomposition of the spatial derivatives of eta, provided by the extension <a class="el" href="classPonca_1_1GLSCurvatureHelper.html">GLSCurvatureHelper</a> (based on the analysis of <a class="el" href="classPonca_1_1GLSDer.html#a0ae73609529b5939e87dabcd94c15e77" title="Compute and return  derivatives.">GLSDer::deta()</a>): </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> Basket&lt;MyPoint, WeightFunc, OrientedSphereFit,    <span class="comment">// Sphere fitting</span></div>
<div class="line">                                  GLSParam,               <span class="comment">// GLS reparametrization</span></div>
<div class="line">                                  OrientedSphereSpaceDer, <span class="comment">// Spatial derivatives</span></div>
<div class="line">                                  GLSDer,                 <span class="comment">// GLS differentiation</span></div>
<div class="line">                                  GLSCurvatureHelper &gt; Fit;</div>
<div class="line"> </div>
<div class="line">Fit fit;</div>
<div class="line"><span class="comment">// Fit primitive</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// The eigen decomposition is called during the fit finalize</span></div>
<div class="line">fit.finalize();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(fit.isStable())</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Get principal curvatures</span></div>
<div class="line">  Scalar k1 = fit.GLSk1();</div>
<div class="line">  Scalar k2 = fit.GLSk2();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get associated directions</span></div>
<div class="line">  VectorType d1 = fit.GLSk1Direction();</div>
<div class="line">  VectorType d2 = fit.GLSk2Direction();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get gaussian curvature</span></div>
<div class="line">  Scalar K = fit.GLSGaussianCurvature();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="fitting_going_further"></a>
Going Further</h1>
<p>This page was intended to show you a standard use of the <a class="el" href="namespacePonca.html" title="This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...">Ponca</a> module. However, there is more to it than <a class="el" href="classPonca_1_1OrientedSphereFit.html" title="Algebraic Sphere fitting procedure on oriented point sets.">Ponca::OrientedSphereFit</a>, as shown in its <a href="namespace_grenaille.html"><b>reference</b></a>. For example, you can create a totally different <a class="el" href="classPonca_1_1Basket.html" title="Agregator class used to declare specialized structures using CRTP (Curiously Recurring Template Patte...">Basket</a> with a <a class="el" href="classPonca_1_1CompactPlane.html" title="Implicit hyperplane defined by an homogeneous vector .">Ponca::CompactPlane</a> and its extension <a class="el" href="classPonca_1_1CovariancePlaneFit.html" title="Plane fitting procedure using only points position.">Ponca::CovariancePlaneFit</a> using plane instead of algebraic sphere to procede the fit in order to compute <a class="el" href="classPonca_1_1CovariancePlaneFit.html#a1c8fdcc36659a5bce174009e7f282688" title="Implements  surface variation.">Ponca::CovariancePlaneFit::surfaceVariation</a>. We encourage you to make your own tests and have a look at our <a class="el" href="example_page.html">examples</a>. It will give you ideas about how to use this module inside your own applications. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gabfd697aebf07c1b5c8be5ee401e2dc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfd697aebf07c1b5c8be5ee401e2dc84">&#9670;&nbsp;</a></span>FIT_RESULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fitting.html#gabfd697aebf07c1b5c8be5ee401e2dc84">Ponca::FIT_RESULT</a> : unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum corresponding to the state of a fitting method (and what the finalize function can return) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabfd697aebf07c1b5c8be5ee401e2dc84a86d1e5381a39092fbe5560583c23d64c"></a>STABLE&#160;</td><td class="fielddoc"><p>The fitting is stable an ready to use (and having more than 6 neighbours) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabfd697aebf07c1b5c8be5ee401e2dc84ab13222e506596eb607093af1a1de3e39"></a>UNSTABLE&#160;</td><td class="fielddoc"><p>The fitting is ready to use but it can be unstable (and having between 3 and 6 neighbors) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabfd697aebf07c1b5c8be5ee401e2dc84a08d57dd200082f67128b5274049dda41"></a>UNDEFINED&#160;</td><td class="fielddoc"><p>The fitting is undefined, you can't use it for valid results (and having less than 3 neighbors) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabfd697aebf07c1b5c8be5ee401e2dc84a0d50cd1855fec459b2c5756ec38d4a17"></a>NEED_OTHER_PASS&#160;</td><td class="fielddoc"><p>The fitting procedure needs to analyse the neighborhood another time. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabfd697aebf07c1b5c8be5ee401e2dc84a405923cb4af5edb343e87ec895c01c2c"></a>NBMAX&#160;</td><td class="fielddoc"><p>Nb enums. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacePonca_html"><div class="ttname"><a href="namespacePonca.html">Ponca</a></div><div class="ttdoc">This module provides efficient methods for the fitting and analysis of point-clouds in arbitrary dime...</div><div class="ttdef"><b>Definition:</b> limitedPriorityQueue.h:14</div></div>
<div class="ttc" id="agroup__fitting_html_ggabfd697aebf07c1b5c8be5ee401e2dc84a86d1e5381a39092fbe5560583c23d64c"><div class="ttname"><a href="group__fitting.html#ggabfd697aebf07c1b5c8be5ee401e2dc84a86d1e5381a39092fbe5560583c23d64c">Ponca::STABLE</a></div><div class="ttdeci">@ STABLE</div><div class="ttdoc">The fitting is stable an ready to use (and having more than 6 neighbours)</div><div class="ttdef"><b>Definition:</b> enums.h:20</div></div>
<div class="ttc" id="agroup__fitting_html_gabfd697aebf07c1b5c8be5ee401e2dc84"><div class="ttname"><a href="group__fitting.html#gabfd697aebf07c1b5c8be5ee401e2dc84">Ponca::FIT_RESULT</a></div><div class="ttdeci">FIT_RESULT</div><div class="ttdef"><b>Definition:</b> enums.h:16</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 3 2021 07:51:25 for Ponca by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
